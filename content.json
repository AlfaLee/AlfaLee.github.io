{"pages":[],"posts":[{"title":"Hexo博客搭建简单步骤","text":"Hexo 博客搭建及部署简单步骤一、博客项目搭建 安装 Node 环境 安装 hexo 博客脚手架 博客项目初始化 新建本地文件夹如 blog 在此文件夹启动命令行 输入 hexo init 博客项目启动 在 blog 文件夹下的命令行输入 hexo serve 或 hexo s 二、部署到 Github 新建 github 账号 配置 SSH Key ① 设置 git 的 user name 和 email git config –global user.name “自己的 git 用户名” git config –global user.email “自己的 git 邮箱” ② 检查是否存在 SSH Key 查看 C:\\Users\\计算机名.ssh 中是否有 id_rsa 和 id_rsa.pub ③ 如果没有 SSH Key，则生成 ssh-keygen -t rsa -C “个人 git 邮箱” ④ 获取 SSH Key 打开 id_rsa.pub 并复制 ⑤ GitHub 账户添加 SSH Key 在 setting 中的 SSH and GPG Keys 中新建 SSH Key ⑥ 验证 ssh -T git@github.com 新建仓库 注意：仓库地址必须和用户地址相同，因为公网访问的时候需要 安装部署插件 hexo-deployer-git npm install –save hexo-deployer-git 设置_config.yml deploy type:git repo:仓库地址 branch: master 部署到远端 执行 hexo deploy 或 hexo d 三、新建博客 执行 hexo new “博客名” 或者 hexo n “博客名” 在 source/_posts 目录下即可看到新博客的 md 文件 hexo clean（清理） → hexo g（生成）→ hexo s（启动） 四、更换主题 下载主题 git clone “主题 git 地址” theme/yilia 修改_config.yml 文件中的 theme：yilia 重新清理 → 生成 → 启动 → 部署到远端","link":"/2021/01/28/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/28/hello-world/"},{"title":"ECMAScript学习笔记","text":"ES6 基础类型let1 .变量不能重复声明 2 .块级作用域 3 .不存在变量提升 4 .不影响作用域链 const 定义常量1 .一定要赋初始值 2 .一般常量使用大写 3 .常量的值不能修改 4 .块级作用域 5 .对于数组和对象元素修改，不算对常量的修改，不会报错 12const TEAM = ['UZI','Ming','Kasa'];TEAM.push('Lifa');//控制台不会报错，因为常量指向的地址没有发生改变，虽然数组元素改变了 变量的解析赋值ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称作解析赋值 1 .数组的解构 123const jijie = [&quot;春&quot;, &quot;夏&quot;, &quot;秋&quot;, &quot;冬&quot;];let [a, b, c, d] = jijie;console.log(a, b, c, d); 2 .对象的解构 123456789101112const obj = { name: &quot;张三&quot;, age: 18, fn: function () { console.log(&quot;testtest&quot;); },};let { name, age, fn } = obj;console.log(name);console.log(age);console.log(fn);fn(); 模板字符串ES6 引入新的声明字符串的方式 特性： 内容可以直接出现换行符 变量可以直接拼接 ${} 123let fistName = &quot;Lee&quot;;let fullName = `${fistName}Alfa`;console.log(fullName); 简化对象写法ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样更简洁 12345678910111213141516171819let objName = &quot;lifa&quot;;let funTest = function () { console.log(&quot;fnTest&quot;);};// let objSimplify={// objName:objName,// funTest:funTest,// anotherFn:function(){// console.log('another');// }// }let objSimplify = { objName, funTest, another(){ console.log(another); }};console.log(objSimplify); 箭头函数ES6 允许使用箭头（=&gt;）定义函数 特性： 1 .this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值，即便是 call 也不可改变 this 的指向 2 .不能作为构造函数实例化对象 3 .不能使用 arguments 对象 4 .箭头函数简写 省略小括号，当形参有且只有一个的时候 省略花括号，当代码体只有一条语句的时候，此时 return 必须省略，而且语句执行的结果就是函数的返回值 箭头函数适合与 this 无关的回调，定时器，数组的方法回调 箭头函数不适合与 this 有关的回调，事件回调，对象的方法 参数默认值ES6 允许给函数参数赋值初始值 1 .形参初始值，具有默认值的参数，一般位置要靠后（潜规则） 2 .与解构赋值结合 123456789101112function connect({ url = &quot;127.0.0.1&quot;, host, username, port }) { console.log(url); console.log(host); console.log(username); console.log(port);}connect({ host: &quot;atguigu.com&quot;, username: &quot;root&quot;, password: &quot;root&quot;, port: 3306,}); rest 参数ES6 引入rest参数，用于获取函数的实参，用来替代 arguments，arguments 不是数组，而 rest 是数组 注意：rest 参数必须要放到参数最后 1234567891011//ES5获取参数方式function date1() { console.log(arguments);}date1(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, typeof arguments);//[Arguments] { '0': 'a', '1': 'b', '2': 'c', '3': 'object' }//ES6方式function date2(a, b, ...rest) { console.log(rest);}date2(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);//[ 'cc', 'dd' ] spread 扩展运算符…扩展运算符能将数组(或伪数组)**转换为逗号分隔的参数序列** 123456const dir = ['东','南','西','北'];function dirFn(){ console.log(arguments);}dirFn(dir);//[Arguments] { '0': [ '东', '南', '西', '北' ] }dirFn(...dir);//[Arguments] { '0': '东', '1': '南', '2': '西', '3': '北' } 应用： 数组合并 123456const arr1 = [&quot;a&quot;, &quot;b&quot;];const arr2 = [&quot;c&quot;, &quot;d&quot;];const fullArr1 = arr1.concat(arr2); //[ 'a', 'b', 'c', 'd' ]console.log(fullArr1);const fullArr2 = [...arr1, ...arr2]; //[ 'a', 'b', 'c', 'd' ]console.log(fullArr2); 数组克隆 将伪数组转换为真数组 12345function spreadFn() { console.log(arguments);//[Arguments] { '0': 'a', '1': 'b' } console.log([...arguments]);//[ 'a', 'b' ]}spreadFn(&quot;a&quot;, &quot;b&quot;); Symbol原始数据类型 Symbol，表示独一无二的值，第七种数据类型 Symbol 特点 Symbol 的值是唯一的，用来解决命名冲突的问题 Symbol 值不能与其他数据进行运算 Symbol 定义的对象属性不能用 for…in 循环遍历，但可以使用 Reflect.ownKeys 来获取对象的所有键名 创建 Symbol Symbol()方式 12345let s = Symbol();console.log(s, typeof s);let s1 = Symbol(&quot;我是描述字符串&quot;);let s2 = Symbol(&quot;我是描述字符串&quot;);console.log(s1 == s2); //false 使用Symbol.for创建1234567let s3 = Symbol.for(&quot;尚硅谷&quot;);let s4 = Symbol.for(&quot;尚硅谷&quot;);let s5 = Symbol.for(&quot;我是描述字符串&quot;);console.log(s3, typeof s3);console.log(s3 == s4);//trueconsole.log(s3 === s4);//trueconsole.log(s3 == s5);//false 七种数据类型 USONB–you are so niubilityu undefined s——string symbol o——object n——null number b——boolean Symbol 创建对象属性123456789101112131415161718192021222324252627282930313233 let game = { up: function () { console.log(&quot;upup&quot;); }, down: function () { console.log(down); }, [Symbol(&quot;left&quot;)]: function () {//此种方法如何调用？ console.log(&quot;left1&quot;); }, [Symbol.for('left')]: function () {//此种方法可以调用 console.log(&quot;left2&quot;); }, }; // console.log(game[Symbol(&quot;left&quot;)]);------------------------------------------------------------------ let methods = { up: Symbol(&quot;up&quot;), down: Symbol(&quot;down&quot;), left: Symbol(&quot;left&quot;), }; game[methods.up] = function () { console.log(&quot;up2&quot;); }; game[methods.down] = function () { console.log(down2); }; game[methods.left] = function () { console.log(&quot;left3&quot;); }; console.log(game); // console.log(game[Symbol('left')]()); console.log(game[Symbol.for('left')]()); Symbol 内置值11 个内置的 Symbol 值，指向语言内部使用的方法,控制对象在特定场景下的表现 Symbol.hasInstance 12345678910class Persong { static [Symbol.hasInstance](param) { console.log(param); console.log(&quot;用来检测类型&quot;); // return true; return false; }}let o = {};console.log(o instanceof Persong); Symbol.isConcatSpreadable 1234let symArr1 = [&quot;1&quot;, &quot;2&quot;];let symArr2 = [&quot;3&quot;, &quot;4&quot;, &quot;5&quot;];symArr2[Symbol.isConcatSpreadable] = false;console.log(symArr1.concat(symArr2));//[&quot;1&quot;, &quot;2&quot;, Array(3)] 迭代器迭代器（Iterator）是一个接口，任何数据结构只要部署了Iterator 接口（即对象中的属性，Symbol.iterator），就可以完成遍历操作。 ES6 创造的新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。（for…in 遍历键名，for…of 遍历键值） 原生具备 iterator 接口的数据（可用 for…of）：Array 、Arguments、Set、Map、String、TypedArray、NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员 接下来不断调用 next 方法，指针一直往后移动，知道指向最有一个成员 每次调用 next 方法返回一个包含 value 和 done 属性的对象 123456789101112let iteratorArr = ['a', 'b', 'c'];console.log(iteratorArr);//获取Symbol.iterator对应的函数，用以创建对象，在可遍历对象的_proto_上let iteratorFunction = iteratorArr[Symbol.iterator];//创建指针对象，使用Symbol.iterator对应的函数创建let iteratorObj = iteratorArr[Symbol.iterator]();console.log(iteratorObj);//指针对象上有next方法,调用console.log(iteratorObj.next());//{value: &quot;a&quot;, done: false}console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());//{value: undefined, done: true} 自定义迭代器遍历对象 1234567891011121314151617181920212223const iteratorData = { name: &quot;二班&quot;, students: [&quot;老二&quot;, &quot;雅兴&quot;, &quot;张超&quot;], [Symbol.iterator]: function () { let index = 0; let _this = this; return { next: function () { if (index &lt; _this.students.length) { const result = { value: _this.students[index], done: false }; index++; return result; } else { const result = { value: _this.students[index], done: true }; return result; } }, }; }, }; for (let v of iteratorData) { console.log(v); } 生成器生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同 迭代器对象信息 123456789101112function* gen() { yield &quot;aaa&quot;; yield &quot;bbb&quot;; yield &quot;ccc&quot;;}let iteratorGen = gen();//返回值为一个迭代器对象console.log(iteratorGen);console.log(iteratorGen.next()); //{value: &quot;aaa&quot;, done: false}for (const v of gen()) { console.log(v); //aaa bbb ccc} 生成器函数参数 函数传参和next方法传参，两种方式 第一个next方法传递的参数不可输出，第二个next方法参数将作为第一个yield返回结果值 123456789101112131415function* gen2(arg){ console.log(arg);//AAA let one = yield '111'; console.log(one);//BBB let two = yield '222'; console.log(two);//CCC let three = yield '333' console.log(three);}//执行获取迭代器对象let paramGen = gen2(&quot;AAA&quot;);console.log(paramGen.next('EEE'));//无输出console.log(paramGen.next('BBB'));//next方法可以传入参数，BBB作为第一个yield返回结果console.log(paramGen.next('CCC'));//CCC将作为第二个yield返回结果console.log(paramGen.next('DDD')); 生成器实例1 .回调地狱问题 js异步编程 文件操作 网络操作 数据库操作 解决回调地狱问题 将异步任务放到yield语句后执行，调用next方法执行yield语句12345678910111213141516171819202122232425function one(){ setTimeout(() =&gt; { console.log(111); iteratorHell.next(); }, 1000);}function two(params) { setTimeout(() =&gt; { console.log(222); iteratorHell.next(); }, 2000);}function three(params) { setTimeout(() =&gt; { console.log(333); // iterator.next(); }, 3000);}function* dealHellFun(params) { yield one(); yield two(); yield three();}let iteratorHell = dealHellFun();iteratorHell.next(); 2 .模拟数据获取 用户数据 订单数据 商品数据 数据是有关联的，要先有用户，根据用户获取订单，在获取商品数据 12345678910111213141516171819202122232425262728function getUser(params) { setTimeout(() =&gt; { let data = '用户数据'; iteratorMall.next(data);//第二次调用next，传入的参数做为第一个yield语句返回结果 }, 1000);}function getOrders(params) { setTimeout(() =&gt; { let data = '订单数据'; iteratorMall.next(data); }, 1000);}function getGoods(params) { setTimeout(() =&gt; { let data = '商品数据'; iteratorMall.next(data); }, 1000);}function* gen3(){ let user = yield getUser(); console.log(user); let orders = yield getOrders(); console.log(orders); let goods = yield getGoods(); console.log(goods);}let iteratorMall = gen3();iteratorMall.next(); Promise基本语法 Promise是ES6引入的异步编程的新解决方案。**语法上Promise是一个构造函数**，用来封装异步操作并可以获取其成功或失败的结果。 Promise构造函数：Promise（excutor）{} Promise.prototype.then方法 Promise.prototype.catch方法 Promise封装Ajax123456789101112131415161718192021let p = new Promise((resolve, reject) =&gt; { //1.创建对象 let xhr = new XMLHttpRequest(); //2.初始化 xhr.open(&quot;get&quot;, &quot;https://api.apiopen.top/getJoke&quot;); //3.发送 xhr.send(); //4.绑定事件，处理相应结果 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } } }; }); p.then(value =&gt; { console.log(value); }).catch(err =&gt; { console.log(err); }); Promise的then方法 then方法的返回结果也是Promise对象，对象状态由回调函数执行结果决定 如果then方法回调函数中返回的结果是*非Promise类型的属性，then返回的promise对象的状态为成功**，返回值为对象的成功的值(即resolve函数传入的值***) 如果then方法回调函数中返回结果是**Promise对象，then返回的promise对象的状态为返回的promise对象的状态**，返回值为返回的promise对象then方法返回的值(resolve函数参数的值) 如果then方法回调函数中返回结果是**抛出错误，then返回的promise对象的状态为rejected**，返回值为抛出错误的值 then方法可以链式调用 1p.then(success=&gt;{},err=&gt;{}).then() 读取多个文件 12345678910111213141516171819202122var fs = require(&quot;fs&quot;);const { resolve } = require(&quot;path&quot;);var readPromise = new Promise((resolve, reject) =&gt; { fs.readFile(&quot;./data/readfile1.txt&quot;, function (err, data1) { // console.log(data1.toString()); resolve(data1); });});readPromise .then((value) =&gt; { return new Promise((resolve, reject) =&gt; { fs.readFile(&quot;./data/readfile2.txt&quot;, function (err, data2) { resolve([value, data2]); }); }); }) .then((value) =&gt; { fs.readFile(&quot;./data/readfile3.txt&quot;, function (err, data3) { value.push(data3); console.log(value.join(&quot;\\r\\n&quot;)); }); }); SetES6提供新的数据结构Set（集合）。它类似于数组，但**成员的值都是唯一的**，集合实现了iterator接口，所以可以使用扩展运算符和for…of…进行遍历。 1 .集合的属性和方法： size 返回集合的元素个数 add 增加一个新元素，返回当前集合 delete 删除元素，返回bool值 has 检测集合中是否包含某个元素，返回bool值 clear 清空集合 2 .应用 数组去重123let setArr1 = [1,2,3,4,5,4,3,2,1];let newArr1 = [...new Set(setArr1)];console.log(newArr1); 交集12345let setArr2 = [4,5,6,5,4];let unionArr = [...new Set(setArr1)].filter(item=&gt;{ return new Set(setArr2).has(item);})console.log(unionArr); 并集12let result = [...new Set([...setArr1,...setArr2])];console.log(result); 差集1234let diffArr = [...new Set(setArr1)].filter(item =&gt; !(new Set(setArr2).has(item)));console.log(diffArr);//[ 1, 2, 3 ]let diffArr2 = [...new Set(setArr2)].filter(item=&gt;new Set(setArr1).has(item));console.log(diffArr2); MapES6提供了Map数据结构。 类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种各类型的值（包括对象）都可以当做键。 Map也实现了iterator接口，所以可以使用扩展运算符和for…of进行遍历 Map的属性和方法： size 返回Map元素的个数 set 增加一个新元素，返回当前Map get 返回简明对象的键值 has 检测Map中是否包含某个元素，返回bool值 clear 清空结合，返回undefined class类作为对象模板，通过class关键字，可以定义类。 基本上，ES6的class可以看做知识一个语法糖，他的绝大部分功能，ES5都可以做到。 新的class写法只是让对象原型的写法更加清晰、更像面向对象的语法而已。 类定义 构造方法，名字必须为constructor，不可修改 方法必须使用ES6方法，不能使用ES5的对象完整形式1234567891011class Phone { constructor(brand, price) { this.brand = brand, this.price = price; } call(){ console.log('打电话'); }}let phone = new Phone('Iphone','5毛');console.log(phone); class静态成员 函数是一个对象，[函数名]为函数对象；[new 函数名]获得的对象是实例对象 属于函数对象而不属于实例对象的属性和方法，称之为静态成员。则**静态成员属于类不属于实例对象** ES5方式实例对象 实例对象和函数对象是不同的，属性和方法是不通的1234567891011//MPhone是函数对象，mPhone是实例对象function MPhone(){}MPhone.name = '小米';MPhone.call = function(){ console.log('Hello mi fans');}let mPhone= new MPhone();//对象上没有构造函数上的属性方法console.log(mPhone.name);//undefined 实例对象和构造函数原型对象是相通的123456789function MPhone(){}MPhone.prototype.name = '小米';//给构造函数上添加属性MPhone.prototype.call = function(){ console.log('Hello mi fans');}let mPhone= new MPhone();console.log(mPhone.name);//小米 ES6中class静态成员 静态成员属于类不属于实例对象 123456789 class StaticPhone{ static name = 'shouji'; static change(){ console.log('static方法'); }}let nokia = new StaticPhone();console.log(nokia.name);//undefinedconsole.log(StaticPhone.name);//手机 对象继承 ES5使用构造函数实现对象继承 1234567891011121314151617181920212223242526272829 //父级function MPhone(brand, price) { this.brand = brand; this.price = price;}MPhone.prototype.call3 = function () { console.log(&quot;打电话&quot;);};//子级function SmartPhone(brand, price, color, size) { //调用父级构造函数初始化代码,避免代码重写 MPhone.call(this, brand, price); this.color = color; this.size = size;}//设置子级构造函数原型SmartPhone.prototype = new MPhone(); //实例对象和构造函数原型上的属性方法是相通的SmartPhone.prototype.constructor = SmartPhone;//声明子级的方法(注意：实例上并不会出现此方法)SmartPhone.photo1 = function () { console.log(&quot;函数对象（父级）方法&quot;);};//声明子级实例的方法SmartPhone.prototype.photo = function () { console.log(&quot;实例对象（子级）方法&quot;);};//实例化const hammer = new SmartPhone(&quot;锤子&quot;, 3333, &quot;黑色&quot;, &quot;5inch&quot;);console.log(hammer); ES6中class对象继承 继承方式：class 子类名 extends 父类名{} 子类中添加super()函数 123456789101112131415161718192021class FatherClass { constructor(brand, price) { this.brand = brand; this.price = price; } call3() { console.log('class父级方法'); }}class SonClass extends FatherClass { constructor(brand, price, color, size) { super(brand, price); this.color = color; this.size = size; } sonFun() { console.log('子类的方法'); }}let sonClass = new SonClass('iPhone', 333, '星空灰', '4inch');console.log(sonClass); 子类对父类方法的重写 子类不可以直接调用父类同名方法，super方法只能出现在constructor class中getter和setter get通常对对象的动态属性进行封装 set添加更多的控制 123456789101112class GetSetClass { get price() { console.log('获取价格'); return 'huoqu' } set price(newVal) { console.log('价格修改'); }}let getSetClass = new GetSetClass();console.log(getSetClass.price);getSetClass.price = '124' 数值扩展 Number.EPSILON是JavaScript表示的最小精度，接近2.22E-16 二进制和八进制 二进制0b开头，八进制0o开头，十六进制ox开头 Number.isFinite检测一个数值是否为有限数 Number.inNaN检测一个数值是否为有限数 Number.parsInt Number.parseFloat字符串转换 Number.isInteger判断一个数是否为整数 Math.trunc将数字的小鼠部分抹掉 Math.sign判断一个数到底为正数 负数 还是零 对象方法扩展 Object.is 判断两个值是否完全相等 12console.log(NaN===NaN);//falseconsole.log(Object.is(NaN,NaN));//true Object.assign 对象的合并 Object.setPrototypeof 设置原型对象 Object.getPrototypeof ES6模块化模块化是将一个大的程序文件，拆分成许多小的文件,然后将小文件组合起来. 优点： 防止命名冲突 代码复用 高维护性 模块化规范产品 CommonJS—&gt;Node Browserify AMD —&gt; requireJS CMD —&gt; seaJS ES6规范 —&gt; 浏览器端规范 ES6模块化语法模块功能主要由两个命令构成：export和import export命令用于规定模块的对外接口 import命令 用于输入其他模块提供的功能(html中引入时要设置script标签的type属性为module) 一、export暴露方式： 分别暴露 1234export let name1 = '分别暴露方式';export function exportFun1(){ console.log('分别暴露方式函数');} 统一暴露 123456let name1 = '分别暴露方式2';function exportFun1(){ console.log('分别暴露方式函数2');}export {name1,exportFun1} 默认暴露 123456export default { name1: &quot;default暴露方式&quot;, exportFun1: function () { console.log(&quot;default暴露方式&quot;); },}; 二、引入模块 通用导入 1import * as m1 from './js/export1.js'//通用的引入方式 解构赋值形式 12345678//分别导出的引入import {name1,exportFun1} from './js/export1.js'//解构赋值方式//统一导出的引入import {name1 as name,exportFun1 as fun} from './js/export2.js'//设置别名解决命名冲突//default导出的引入import {default as m3} from './js/export3.js' 简便形式，只能针对默认暴露 1import m4 from './js/export3.js'//简便形式，只适合default导出的 ES6-浏览器使用ES6模块化方式 直接导入方式 –&gt;app.js方式 在app.js文件引入各个模块文件，然后在html文件中引入app.js文件 12345678910app.js import * as m1 from './export1.js'//通用的引入方式 import { name1 as name, exportFun1 as fun } from './export2.js' import { default as m3 } from './export3.js' import m4 from './export3.js'//简便形式，只适合default导出的 console.log(m1); console.log(name); console.log(m3); console.log(m4); –&gt;Babel方式（ES6→ES5） 并非所有的浏览器支持ES6语法 ES6模块化还不能对npm安装的模块进行导入 步骤： 安装工具babel-cli（babel命令行工具）、 babel-preset-env(预设包，把最新的ES特性转换为ES5)、 browserify(webpack) 语法转换 npx babel 源文件目录 -d dist/js –preset=babel-preset-env ES6语法转换为CommonJS模块规范化语法 浏览器不识别require语法 打包 npx browserify dist/js -o dist/bundle.js ECMAScript7新特性 Array.prototype.includes includes方法用于检测数组中是否包含某个元素，返回布尔类型值 指数运算符 在ES7中引入指数运算符“**”，用来实现幂运算，功能与Math.pow结果相同 ECMAScript8新特性async和await两种语法相结合可以让异步代码像同步代码一样 async函数 async函数的返回值为promise对象，此对象由此函数内部return的状态决定 promise对象的结果由async函数执行的返回结果决定1234567891011121314async function asyncTest() { //返回结果不是一个promise类型的对象，返回的结果就是成功Promise对象 // return;//状态成功 //返回一个字符串 // return 'async函数';//状态成功 //抛出错误，返回的结果是一个失败的Promise // throw new Error('出错啦');//状态失败 return new Promise((resolve, reject) =&gt; { // resolve('状态成功');//指此promise对象状态成功，则async函数状态成功 reject(&quot;状态失败&quot;);//意味着此promise对象状态失败，则async函数状态失败 });}let asyncResult = asyncTest();console.log(asyncResult); await表达式 await必须写在async函数中 await右侧的表达式一般为promise对象 await返回的是promise对象成功的值 await的promise失败了，就会抛出异常，需要通过try…catch捕获处理123456789101112131415let awaitPromise = new Promise((resolve, reject) =&gt; { // resolve('await后面一般为promise对象'); reject('失败');});//await函数写在async中async function awaitFun() { try { let result = await awaitPromise; console.log('await返回的是promise对象成功的值：'); console.log(result); } catch (error) { console.log(error); }}awaitFun(); async和await集合读取文件 1234567891011121314151617181920212223242526272829303132333435363738const fs = require(&quot;fs&quot;);function getFile1() { return new Promise((resolve, reject) =&gt; { fs.readFile(&quot;./data/readfile1.txt&quot;, function (err, data1) { // console.log(data1.toString()); if(err) reject(err) resolve(data1); }); });} function getFile2() { return new Promise((resolve, reject) =&gt; { fs.readFile(&quot;./data/readfile2.txt&quot;, function (err, data1) { // console.log(data1.toString()); if(err) reject(err) resolve(data1); }); });};function getFile3() { return new Promise((resolve, reject) =&gt; { fs.readFile(&quot;./data/readfile3.txt&quot;, function (err, data1) { // console.log(data1.toString()); if(err) reject(err) resolve(data1); }); });}async function getAllContent() { let data1 = await getFile1(); let data2 = await getFile2(); let data3 = await getFile3(); console.log(data1.toString()); console.log(data2.toString()); console.log(data3.toString());}getAllContent(); async和await结合封装Ajax 123456789101112131415161718192021222324252627282930function getData() { return new Promise((resolve, reject) =&gt; { // var XMLHttpRequest = require(&quot;xmlhttprequest&quot;).XMLHttpRequest; //1.创建对象 let xhr = new XMLHttpRequest(); //2.初始化 xhr.open(&quot;GET&quot;, &quot;https://api.apiopen.top/getJoke&quot;); //3.发送 xhr.send(); //4.绑定事件，处理相应结果 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject(); } } }; });}//promise then 方式// getData().then(value=&gt;{console.log(value);},reason=&gt;{// console.log(reason);// });async function main() { let result = await getData(); console.log(result);}main(); ES8对象方法扩展 Object.values()方法返回一个给定对象的所有可枚举属性值的数组 Object.entries()方法返回一个给定对象自身可遍历属性[key,value]的数组 Object.getOwnPropertyDescriptors()方法返回指定对象所有自身属性的描述对象 12345678910const es8Obj = { url:'2.2.2.2', method:'get', host:'localhost'}console.log(Object.keys(es8Obj));console.log(Object.values(es8Obj));console.log(Object.entries(es8Obj));console.log(Object.getOwnPropertyDescriptors(es8Obj)); ES9 扩展运算符与rest参数 Rest参数与spread扩展运算符在ES6中已经引入，不过ES6中只针对数组。 在ES9在为对象提供了像数组一样的rest参数和扩展运算符 ES9正则扩展命名捕获分组12345678910111213let url = '&lt;a href=&quot;https:baidu.com&quot;&gt;百度&lt;/a&gt;';let reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\\/a&gt;/;let result = reg.exec(url);console.log(result);console.log(result[0]);console.log(result[1]);console.log(result[2]);let reg2 = /&lt;a href=&quot;(?&lt;str&gt;.*)&quot;&gt;(?&lt;name&gt;.*)&lt;\\/a&gt;/;let result2 = reg2.exec(url);console.log(result2);console.log(result2.groups.str);console.log(result2[1]); 反向断言根据目标前后内容做唯一性识别 12345678let str = &quot;JS1234你知道么555啦啦啦&quot;;//匹配555let reg = /\\d+(?=啦)/;let result = reg.exec(str);console.log(result);//555//反向断言let reg2 = /(?&lt;=么)\\d+/console.log(reg2.exec(str));//555 dotAll模式dot . 元字符–&gt;匹配处换行符之外的任意字符 dotAll模式使.可以匹配任意字符 ES10Object.fromEntries 传入二维数组,创建对象123let arr = [['a','es10学习'],['b','es10对象扩展']];let es10Obj = Object.fromEntries(arr);console.log(es10Obj);//{ a: 'es10学习', b: 'es10对象扩展' } 传入Map123456let map = new Map();map.set(&quot;name&quot;, &quot;aaa&quot;);let e = Object.fromEntries(map);console.log(e); //{name:'aaa'}//fromEntries与entries逆操作console.log(Object.entries(e)); //['name','aaa'] trimStart与trimEnd 用以清除字符前后的空白 flat与flatMap数组的两个方法 flat将多为数组转换为低维数组,参数为整数，表示深度，默认值为1 flatMap()数组的方法，与Array.map类似，可以将遍历的item返回的结果降低维度 Symbol.prototype.description获取Symbol函数参数值 ES11私有属性对属性的封装，私有属性用“#”标识 123456789101112131415161718class Person{ //公有属性 name; //私有属性 #age; #weight; constructor(name,age,weight){ this.name = name; this.#age = age; this.#weight = weight; } intro(){ console.log(this.#age); }}let person = new Person('aa',13,22)console.log(person.intro());// console.log(person.#age);//报错 Promise批处理方法 Promise.allSettled() 接收Promise数组，返回Promise对象 返回的结果永远是成功的状态，结果为每一个promise状态和结果值 Promise.all() 接收Promise数组 返回结果由数组中每一个promise状态决定，全成功才成功 字符串扩展方法matchAllString.prototype.matchAll用来得到正则批量匹配得到的结果 可选链操作符 形式：?.的组合 对象类型参数层级比较深，此符号可避免层层判断 动态import实现按需加载 import()函数，传入资源路径，返回结果为promise对象 BigInt用于大整数数值运算 在普通数字后加一个n即为大整型 转换为此类型方法BigInt(),只能传入整数 不能与普通整数做运算，需要把普通整数转换为BigInt类型 globalThis全局的this，始终指向全局对象","link":"/2021/03/04/ECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[]}