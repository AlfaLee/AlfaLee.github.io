<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise理解</title>
      <link href="2021/03/09/Promise%E7%90%86%E8%A7%A3/"/>
      <url>2021/03/09/Promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-理解"><a href="#Promise-理解" class="headerlink" title="Promise 理解"></a>Promise 理解</h1><h2 id="Promise-是什么？"><a href="#Promise-是什么？" class="headerlink" title="Promise 是什么？"></a>Promise 是什么？</h2><ol><li>抽象表达</li></ol><ul><li>Promise 是一门新的技术（ES6 规范）</li><li>Promise 是 JS 中进行异步编程的新解决方案（旧方案单纯使用回调函数）</li></ul><ol start="2"><li>具体表达</li></ol><ul><li>从语法上看，Promise 是一个构造函数</li><li>从功能上看，Promise 对象是一个用来封装一个异步操作并可以获取其成功/失败的结果值</li></ul><h2 id="Promise-的状态改变"><a href="#Promise-的状态改变" class="headerlink" title="Promise 的状态改变"></a>Promise 的状态改变</h2><ol><li>pendding 变为 resolved</li><li>pendding 变为 rejected</li></ol><p>说明：</p><ul><li>只有这 2 种，且一个 promise 对象只能改变一次</li><li>无论变为成功还是失败，都会有一个结果数据</li><li>成功的结果数据一般称为 value，失败的结果数据一般称为 reason</li></ul><h2 id="Promise-基本流程"><a href="#Promise-基本流程" class="headerlink" title="Promise 基本流程"></a>Promise 基本流程</h2><p><img src="./imgs/promise%E6%B5%81%E7%A8%8B.png" alt="avatar"></p><h2 id="Promise-基本使用"><a href="#Promise-基本使用" class="headerlink" title="Promise 基本使用"></a>Promise 基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.创建一个Promise对象</span><br><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;执行器函数，同步回调</span><br><span class="line">  let time &#x3D; new Date();</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    if (time % 2) &#123;</span><br><span class="line">      resolve(&quot;promise成功状态&quot; + time);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&quot;promise失败时间&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  &#x2F;&#x2F;接收得到成功的value值</span><br><span class="line">  (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-Promise-的原因"><a href="#使用-Promise-的原因" class="headerlink" title="使用 Promise 的原因"></a>使用 Promise 的原因</h2><h3 id="（一）、Promise-方式指定回调函数的方式更加灵活"><a href="#（一）、Promise-方式指定回调函数的方式更加灵活" class="headerlink" title="（一）、Promise 方式指定回调函数的方式更加灵活"></a>（一）、Promise 方式指定回调函数的方式更加灵活</h3><ol><li>纯异步任务</li></ol><ul><li>其回调函数需要提前指定，在启动异步任务之前就要指定；</li><li>回调函数必须再启动异步任务之前指定</li></ul><ol start="2"><li>Promise 方式</li></ol><p>启动异步任务=&gt;返回 promise 对象=&gt;给 promise 对象绑定回调函数（甚至可以再异步任务之后）</p><ul><li>① 先启动执行器函数，执行器函数执行启动后才得到一个 promise 对象；</li><li>② 执行器函数启动，则异步任务启动，异步任务处理过程中，未完成；</li><li>③ 回调函数可以随后指定，无需提前指定；</li></ul><h3 id="（二）、Promise-支持链式调用，可以解决回调地狱问题"><a href="#（二）、Promise-支持链式调用，可以解决回调地狱问题" class="headerlink" title="（二）、Promise 支持链式调用，可以解决回调地狱问题"></a>（二）、Promise 支持链式调用，可以解决回调地狱问题</h3><p>回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p><p>解决方案：promise 链式调用</p><p>async/await:回调地狱的终极解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function request() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result &#x3D; await doSomething();</span><br><span class="line">    const newResult &#x3D; await doSomethingElse();</span><br><span class="line">    const finalResult &#x3D; await doThirdThing();</span><br><span class="line">    console.log(finalResult);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    failureCallback(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise"></a>如何使用 Promise</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol><li><p>Promise 构造函数：Promise（excutor）{}</p><ul><li>excutor 函数：同步执行 （resolve,reject）=&gt;{}</li><li>resolve 函数：内部定义成功时我们调用的函数 value=&gt;{}</li><li>reject 函数：内部定义失败时我们调用的函数 reason=&gt;{}</li></ul></li><li><p>Promise.prototype.then 方法：（onResolved,onRejected）=&gt;{}</p><ul><li><p>onResolved 函数：成功的回调函数(value)=&gt;{}</p></li><li><p>onRejected 函数：失败的回调函数(reason)=&gt;{}</p><p>说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，<strong><em>返回一个新的 promise 对象</em></strong></p></li></ul></li><li><p>Promise.prototype.catch 方法：（onRejected）=&gt;{}</p><ul><li><p>onRejected 函数：失败的回调函数(reason)=&gt;{}</p><p>说明：then()语法糖，相当于：then(undefined,onRejected)</p></li></ul></li><li><p>Promise.resolve 方法：(value)=&gt;{}</p><ul><li><p>value:成功的数据或 promise 对象</p><p>说明：<strong><em>resolve 方法返回一个成功/失败的 promise 对象</em></strong></p></li></ul></li><li><p>Promise.reject 方法:(reason)=&gt;{}</p><ul><li>reason:失败的原因</li></ul><p>说明：返回一个失败的 promise 对象</p></li><li><p>Promise.all 方法：(promise)=&gt;{}</p><ul><li><p>promises：包含 n 个 promise 数组</p><p>说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p></li></ul></li><li><p>Promise.race 方法：(promise)=&gt;{}</p><ul><li><p>promises:包含 n 个 promise 的数组</p><p>说明：返回一个新的 promise，最先完成的 promise 的结果状态就是最终的结果状态</p></li></ul></li></ol><h2 id="Promise-几个关键问题"><a href="#Promise-几个关键问题" class="headerlink" title="Promise 几个关键问题"></a>Promise 几个关键问题</h2><ol><li>如何改变 promise 的状态</li></ol><ul><li>① resolve(value):如果当前时 pendding 就会变成 resolved</li><li>② reject(reason):如果当前时 pendding 就会变成 rejected</li><li>③ 抛出异常：如果当前时 pendding 就会变成 rejected</li></ul><ol start="2"><li>一个 promise 指定多个成功/失败回调函数，都会调用？</li></ol><ul><li>当 promise 改变为对应状态时都会调用</li></ul><ol start="3"><li>改变 promise 状态和指定回调函数谁先谁后？</li></ol><ul><li><p>（1）都有可能，正常情况下时先指定回调再改变状态，但也可以先改变状态再指定回调</p></li><li><p>（2）如何先改变状态再指定回调？</p><ul><li>① 在执行器中直接调用 resolve()/reject()</li><li>② 延迟更长时间才调用 then</li></ul></li><li><p>(3)什么时候才能得到数据？</p><ul><li>① 如果先指定的回调，那当状态改变时，回调函数就会调用，得到数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;123&quot;);&#x2F;&#x2F;后改变状态（同时指定数据），异步执行回调函数</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;).then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;&#x2F;&#x2F;先指定回调函数，保存当前指定的回调函数</span><br><span class="line">    console.log(&quot;先指定回调函数&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">(reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>② 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;123&quot;); &#x2F;&#x2F;先改变的状态（同时指定数据）</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;后指定回调函数，异步执行回调函数</span><br><span class="line">    console.log(&quot;123&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="4"><li>promise.then()返回的 promise 的结果状态由什么决定？</li></ol><ul><li>(1)简单表达式：由 then()指定的回调函数执行的结果决定</li><li>(2)详细表达：<ul><li>① then()指定的回调函数执行的结果抛出异常，新 promise（then 方法返回的 promise）变为 rejected,reason 为抛出的异常；</li><li>② then()指定的回调函数执行的结果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值</li><li>③ then()指定的回调函数执行的结果返回的是另一个新的 promise，此 promise 的结果将会成为新 promise 的结果</li></ul></li></ul><ol start="5"><li>promise 如何串联多个操作任务？</li></ol><ul><li>(1)promise 的 then()返回一个新的 promise，可以看成 then()的链式调用</li><li>(2)通过 then 的链式调用串联多个同步/异步任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行任务1(异步)&quot;);</span><br><span class="line">    resolve(1);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2（同步）&quot;);</span><br><span class="line">    return 2; &#x2F;&#x2F;返回一个常量，（同步返回直接return就行）决定then返回的promise为成功状态，值为2</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务2的结果&quot; + value);</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;异步操作则要由promise封装</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;执行任务3（异步）&quot;);</span><br><span class="line">        resolve(3);</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;111&quot;);</span><br><span class="line">        &#x2F;&#x2F; return 3; &#x2F;&#x2F;下一个then不会输出，不是当前then方法的return，那就运行到此，下一个then也不会执行</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;222&quot;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">      &#x2F;&#x2F;   console.log(&quot;333&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不行，异步应该包含在一个promise对象中才能传递下去</span><br><span class="line">    &#x2F;&#x2F;这样就不能按顺序输出，则return的值不能被后续then接收到则会出现undefined</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 执行任务1(异步)</span><br><span class="line">    任务1结果：1</span><br><span class="line">    执行任务2（同步）</span><br><span class="line">    任务2的结果2</span><br><span class="line">    任务3结果undefined</span><br><span class="line">    执行任务4</span><br><span class="line">    任务4结果undefined</span><br><span class="line">    执行任务3（异步）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   console.log(&quot;执行任务3（异步）&quot;);</span><br><span class="line">    &#x2F;&#x2F;   return 3;</span><br><span class="line">    &#x2F;&#x2F; &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务3结果&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务4&quot;);</span><br><span class="line">    return Promise.resolve(4)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; console.log(p);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务4结果&quot; + value); &#x2F;&#x2F;任务4结果undefined</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>promise 异常穿透</li></ol><ul><li>then 返回的 promise 失败的情况：① 抛异常 ② 返回失败的 promise</li><li>异常一层层传递下去到 catch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;   resolve(1);</span><br><span class="line">  reject(1);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2&quot;);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;任务2的结果&quot; + value);</span><br><span class="line">      return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; (reason) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   throw error;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;任务3结果&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; (reason) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   throw error;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行错误：&quot; + reason);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>(1)当使用 promise 的 then 链式调用时，可以在最后指定失败的问题</li><li>(2)前面任何操作出了异常，都会传到最后失败的回调中</li></ul><ol start="7"><li>中断 promise 链？</li></ol><ul><li>(1)当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数</li><li>(2)办法：在回调函数中返回一个 pendding 状态的 promise 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;   resolve(1);</span><br><span class="line">  reject(1);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2&quot;);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行错误：&quot; + reason);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 未中断</span><br><span class="line">     * return 2; &#x2F;&#x2F;返回下一个then的value</span><br><span class="line">     * return Promise.reject(2); &#x2F;&#x2F;进入下一个then的reason</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中断情况</span><br><span class="line">     *&#x2F;</span><br><span class="line">    return new Promise(() &#x3D;&gt; &#123;&#125;); &#x2F;&#x2F;返回一个pendding的promise，中断promise链</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    (reason) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/28/hello-world/"/>
      <url>2021/01/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
