<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise理解</title>
      <link href="2021/03/09/Promise%E7%90%86%E8%A7%A3/"/>
      <url>2021/03/09/Promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-理解"><a href="#Promise-理解" class="headerlink" title="Promise 理解"></a>Promise 理解</h1><h2 id="Promise-是什么？"><a href="#Promise-是什么？" class="headerlink" title="Promise 是什么？"></a>Promise 是什么？</h2><ol><li>抽象表达</li></ol><ul><li>Promise 是一门新的技术（ES6 规范）</li><li>Promise 是 JS 中进行异步编程的新解决方案（旧方案单纯使用回调函数）</li></ul><ol start="2"><li>具体表达</li></ol><ul><li>从语法上看，Promise 是一个构造函数</li><li>从功能上看，Promise 对象是一个用来封装一个异步操作并可以获取其成功/失败的结果值</li></ul><h2 id="Promise-的状态改变"><a href="#Promise-的状态改变" class="headerlink" title="Promise 的状态改变"></a>Promise 的状态改变</h2><ol><li>pendding 变为 resolved</li><li>pendding 变为 rejected</li></ol><p>说明：</p><ul><li>只有这 2 种，且一个 promise 对象只能改变一次</li><li>无论变为成功还是失败，都会有一个结果数据</li><li>成功的结果数据一般称为 value，失败的结果数据一般称为 reason</li></ul><h2 id="Promise-基本流程"><a href="#Promise-基本流程" class="headerlink" title="Promise 基本流程"></a>Promise 基本流程</h2><p><img src="./imgs/promise%E6%B5%81%E7%A8%8B.png" alt="avatar"></p><h2 id="Promise-基本使用"><a href="#Promise-基本使用" class="headerlink" title="Promise 基本使用"></a>Promise 基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.创建一个Promise对象</span><br><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;执行器函数，同步回调</span><br><span class="line">  let time &#x3D; new Date();</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    if (time % 2) &#123;</span><br><span class="line">      resolve(&quot;promise成功状态&quot; + time);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&quot;promise失败时间&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  &#x2F;&#x2F;接收得到成功的value值</span><br><span class="line">  (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-Promise-的原因"><a href="#使用-Promise-的原因" class="headerlink" title="使用 Promise 的原因"></a>使用 Promise 的原因</h2><h3 id="（一）、Promise-方式指定回调函数的方式更加灵活"><a href="#（一）、Promise-方式指定回调函数的方式更加灵活" class="headerlink" title="（一）、Promise 方式指定回调函数的方式更加灵活"></a>（一）、Promise 方式指定回调函数的方式更加灵活</h3><ol><li>纯异步任务</li></ol><ul><li>其回调函数需要提前指定，在启动异步任务之前就要指定；</li><li>回调函数必须再启动异步任务之前指定</li></ul><ol start="2"><li>Promise 方式</li></ol><p>启动异步任务=&gt;返回 promise 对象=&gt;给 promise 对象绑定回调函数（甚至可以再异步任务之后）</p><ul><li>① 先启动执行器函数，执行器函数执行启动后才得到一个 promise 对象；</li><li>② 执行器函数启动，则异步任务启动，异步任务处理过程中，未完成；</li><li>③ 回调函数可以随后指定，无需提前指定；</li></ul><h3 id="（二）、Promise-支持链式调用，可以解决回调地狱问题"><a href="#（二）、Promise-支持链式调用，可以解决回调地狱问题" class="headerlink" title="（二）、Promise 支持链式调用，可以解决回调地狱问题"></a>（二）、Promise 支持链式调用，可以解决回调地狱问题</h3><p>回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p><p>解决方案：promise 链式调用</p><p>async/await:回调地狱的终极解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function request() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result &#x3D; await doSomething();</span><br><span class="line">    const newResult &#x3D; await doSomethingElse();</span><br><span class="line">    const finalResult &#x3D; await doThirdThing();</span><br><span class="line">    console.log(finalResult);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    failureCallback(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise"></a>如何使用 Promise</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol><li><p>Promise 构造函数：Promise（excutor）{}</p><ul><li>excutor 函数：同步执行 （resolve,reject）=&gt;{}</li><li>resolve 函数：内部定义成功时我们调用的函数 value=&gt;{}</li><li>reject 函数：内部定义失败时我们调用的函数 reason=&gt;{}</li></ul></li><li><p>Promise.prototype.then 方法：（onResolved,onRejected）=&gt;{}</p><ul><li><p>onResolved 函数：成功的回调函数(value)=&gt;{}</p></li><li><p>onRejected 函数：失败的回调函数(reason)=&gt;{}</p><p>说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，<strong><em>返回一个新的 promise 对象</em></strong></p></li></ul></li><li><p>Promise.prototype.catch 方法：（onRejected）=&gt;{}</p><ul><li><p>onRejected 函数：失败的回调函数(reason)=&gt;{}</p><p>说明：then()语法糖，相当于：then(undefined,onRejected)</p></li></ul></li><li><p>Promise.resolve 方法：(value)=&gt;{}</p><ul><li><p>value:成功的数据或 promise 对象</p><p>说明：<strong><em>resolve 方法返回一个成功/失败的 promise 对象</em></strong></p></li></ul></li><li><p>Promise.reject 方法:(reason)=&gt;{}</p><ul><li>reason:失败的原因</li></ul><p>说明：返回一个失败的 promise 对象</p></li><li><p>Promise.all 方法：(promise)=&gt;{}</p><ul><li><p>promises：包含 n 个 promise 数组</p><p>说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p></li></ul></li><li><p>Promise.race 方法：(promise)=&gt;{}</p><ul><li><p>promises:包含 n 个 promise 的数组</p><p>说明：返回一个新的 promise，最先完成的 promise 的结果状态就是最终的结果状态</p></li></ul></li></ol><h2 id="Promise-几个关键问题"><a href="#Promise-几个关键问题" class="headerlink" title="Promise 几个关键问题"></a>Promise 几个关键问题</h2><ol><li>如何改变 promise 的状态</li></ol><ul><li>① resolve(value):如果当前时 pendding 就会变成 resolved</li><li>② reject(reason):如果当前时 pendding 就会变成 rejected</li><li>③ 抛出异常：如果当前时 pendding 就会变成 rejected</li></ul><ol start="2"><li>一个 promise 指定多个成功/失败回调函数，都会调用？</li></ol><ul><li>当 promise 改变为对应状态时都会调用</li></ul><ol start="3"><li>改变 promise 状态和指定回调函数谁先谁后？</li></ol><ul><li><p>（1）都有可能，正常情况下时先指定回调再改变状态，但也可以先改变状态再指定回调</p></li><li><p>（2）如何先改变状态再指定回调？</p><ul><li>① 在执行器中直接调用 resolve()/reject()</li><li>② 延迟更长时间才调用 then</li></ul></li><li><p>(3)什么时候才能得到数据？</p><ul><li>① 如果先指定的回调，那当状态改变时，回调函数就会调用，得到数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;123&quot;);&#x2F;&#x2F;后改变状态（同时指定数据），异步执行回调函数</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;).then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;&#x2F;&#x2F;先指定回调函数，保存当前指定的回调函数</span><br><span class="line">    console.log(&quot;先指定回调函数&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">(reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>② 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(&quot;123&quot;); &#x2F;&#x2F;先改变的状态（同时指定数据）</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;后指定回调函数，异步执行回调函数</span><br><span class="line">    console.log(&quot;123&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="4"><li>promise.then()返回的 promise 的结果状态由什么决定？</li></ol><ul><li>(1)简单表达式：由 then()指定的回调函数执行的结果决定</li><li>(2)详细表达：<ul><li>① then()指定的回调函数执行的结果抛出异常，新 promise（then 方法返回的 promise）变为 rejected,reason 为抛出的异常；</li><li>② then()指定的回调函数执行的结果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值</li><li>③ then()指定的回调函数执行的结果返回的是另一个新的 promise，此 promise 的结果将会成为新 promise 的结果</li></ul></li></ul><ol start="5"><li>promise 如何串联多个操作任务？</li></ol><ul><li>(1)promise 的 then()返回一个新的 promise，可以看成 then()的链式调用</li><li>(2)通过 then 的链式调用串联多个同步/异步任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行任务1(异步)&quot;);</span><br><span class="line">    resolve(1);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2（同步）&quot;);</span><br><span class="line">    return 2; &#x2F;&#x2F;返回一个常量，（同步返回直接return就行）决定then返回的promise为成功状态，值为2</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务2的结果&quot; + value);</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;异步操作则要由promise封装</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;执行任务3（异步）&quot;);</span><br><span class="line">        resolve(3);</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;111&quot;);</span><br><span class="line">        &#x2F;&#x2F; return 3; &#x2F;&#x2F;下一个then不会输出，不是当前then方法的return，那就运行到此，下一个then也不会执行</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;222&quot;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">      &#x2F;&#x2F;   console.log(&quot;333&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不行，异步应该包含在一个promise对象中才能传递下去</span><br><span class="line">    &#x2F;&#x2F;这样就不能按顺序输出，则return的值不能被后续then接收到则会出现undefined</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 执行任务1(异步)</span><br><span class="line">    任务1结果：1</span><br><span class="line">    执行任务2（同步）</span><br><span class="line">    任务2的结果2</span><br><span class="line">    任务3结果undefined</span><br><span class="line">    执行任务4</span><br><span class="line">    任务4结果undefined</span><br><span class="line">    执行任务3（异步）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   console.log(&quot;执行任务3（异步）&quot;);</span><br><span class="line">    &#x2F;&#x2F;   return 3;</span><br><span class="line">    &#x2F;&#x2F; &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务3结果&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务4&quot;);</span><br><span class="line">    return Promise.resolve(4)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; console.log(p);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务4结果&quot; + value); &#x2F;&#x2F;任务4结果undefined</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>promise 异常穿透</li></ol><ul><li>then 返回的 promise 失败的情况：① 抛异常 ② 返回失败的 promise</li><li>异常一层层传递下去到 catch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;   resolve(1);</span><br><span class="line">  reject(1);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2&quot;);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;任务2的结果&quot; + value);</span><br><span class="line">      return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; (reason) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   throw error;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;任务3结果&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; (reason) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;   throw error;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行错误：&quot; + reason);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>(1)当使用 promise 的 then 链式调用时，可以在最后指定失败的问题</li><li>(2)前面任何操作出了异常，都会传到最后失败的回调中</li></ul><ol start="7"><li>中断 promise 链？</li></ol><ul><li>(1)当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数</li><li>(2)办法：在回调函数中返回一个 pendding 状态的 promise 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;   resolve(1);</span><br><span class="line">  reject(1);</span><br><span class="line">&#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;任务1结果：&quot; + value);</span><br><span class="line">    console.log(&quot;执行任务2&quot;);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;执行错误：&quot; + reason);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 未中断</span><br><span class="line">     * return 2; &#x2F;&#x2F;返回下一个then的value</span><br><span class="line">     * return Promise.reject(2); &#x2F;&#x2F;进入下一个then的reason</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中断情况</span><br><span class="line">     *&#x2F;</span><br><span class="line">    return new Promise(() &#x3D;&gt; &#123;&#125;); &#x2F;&#x2F;返回一个pendding的promise，中断promise链</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (value) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    (reason) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise预备</title>
      <link href="2021/03/09/Promise%E9%A2%84%E5%A4%87/"/>
      <url>2021/03/09/Promise%E9%A2%84%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="区别实例对象和函数对象"><a href="#区别实例对象和函数对象" class="headerlink" title="区别实例对象和函数对象"></a>区别实例对象和函数对象</h1><ul><li><strong><em>函数对象</em></strong>：将函数作为对象使用时，简称为函数对象</li><li><strong><em>实例对象</em></strong>：new 函数产生的对象，简称为对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;括号的左边是函数，点号的左边是对象</span><br><span class="line">&#x2F;&#x2F;所有函数都是Function的实例对象</span><br><span class="line">function Fn()&#123;&#x2F;&#x2F;这里Fn是函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const fn &#x3D;  new Fn();&#x2F;&#x2F;这里fn是实例对象（简称对象），Fn是构造函数</span><br><span class="line">console.log(Fn.prototype);&#x2F;&#x2F;这里Fn是函数对象</span><br><span class="line">Fn.call(&#123;&#125;);&#x2F;&#x2F;Fn是函数对象</span><br><span class="line">Fn.bind(&#123;&#125;);&#x2F;&#x2F;函数对象才有bind方法，</span><br><span class="line">$(&#39;#test&#39;);&#x2F;&#x2F;$是jQuery函数</span><br><span class="line">$.get(&#39;&#x2F;test&#39;);&#x2F;&#x2F;$是jQuery函数对象</span><br><span class="line"></span><br><span class="line">function Person(params)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两种类型的回调函数"><a href="#两种类型的回调函数" class="headerlink" title="两种类型的回调函数"></a>两种类型的回调函数</h1><h2 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h2><ul><li>理解：立即执行，完全执行完了才结束，不会放入回调队列中</li><li>例子：数组遍历相关的回调函数/Promise 的 excutor 函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1,2,3];</span><br><span class="line">&#x2F;&#x2F;遍历回调，同步回调函数（只有回调完成，才会执行后面），不会放入回调队列，一上来就执行</span><br><span class="line">arr.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#39;forEach之后执行&#39;);</span><br><span class="line">结果:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">forEach之后执行</span><br></pre></td></tr></table></figure><h2 id="异步回调："><a href="#异步回调：" class="headerlink" title="异步回调："></a>异步回调：</h2><ul><li>理解：不会立即执行，会放入回调队列中将来执行</li><li>例子：定时器回调/ajax 回调/Promise 的成功|失败的回调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;异步回调函数，会放入队列中将来执行，先执行启动任务，只是启动，处理需要时间</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;异步 回调函数，会放入队列中将来执行</span><br><span class="line">    console.log(&#39;timeout callback&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&#39;setTimeout（）之后&#39;);</span><br><span class="line">result:</span><br><span class="line">setTimeout（）之后</span><br><span class="line">timeout callback</span><br></pre></td></tr></table></figure><h1 id="JS-的-error-处理"><a href="#JS-的-error-处理" class="headerlink" title="JS 的 error 处理"></a>JS 的 error 处理</h1><p>目标：进一步理解 JS 中的错误（Error）和错误处理</p><ol><li>常见错误类型</li></ol><ul><li>Error：所有错误的父类型</li><li>ReferenceError：引用的变量不存在</li><li>TypeError:数据类型不正确</li><li>RangeError：数据值不在其所允许的范围内（如：递归调用超出范围）</li><li>SyntaxError：语法错误</li></ul><ol start="2"><li>错误处理</li></ol><ul><li>捕获错误：try…catch</li><li>抛出错误：throw error</li></ul><p>未捕获错误，下面的代码不会执行</p><ol start="3"><li>错误对象</li></ol><ul><li>message 属性：错误相关信息</li><li>stack 属性：函数调用栈记录信息</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript学习笔记</title>
      <link href="2021/03/04/ECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/04/ECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6-基础类型"><a href="#ES6-基础类型" class="headerlink" title="ES6 基础类型"></a>ES6 基础类型</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>1 .变量不能重复声明</p><p>2 .块级作用域</p><p>3 .不存在变量提升</p><p>4 .不影响作用域链</p><h2 id="const-定义常量"><a href="#const-定义常量" class="headerlink" title="const 定义常量"></a>const 定义常量</h2><p>1 .一定要赋初始值</p><p>2 .一般常量使用大写</p><p>3 .常量的值不能修改</p><p>4 .块级作用域</p><p>5 .对于数组和对象元素修改，不算对常量的修改，不会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const TEAM &#x3D; [&#39;UZI&#39;,&#39;Ming&#39;,&#39;Kasa&#39;];</span><br><span class="line">TEAM.push(&#39;Lifa&#39;);&#x2F;&#x2F;控制台不会报错，因为常量指向的地址没有发生改变，虽然数组元素改变了</span><br></pre></td></tr></table></figure><h2 id="变量的解析赋值"><a href="#变量的解析赋值" class="headerlink" title="变量的解析赋值"></a>变量的解析赋值</h2><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称作解析赋值</p><p>1 .数组的解构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const jijie &#x3D; [&quot;春&quot;, &quot;夏&quot;, &quot;秋&quot;, &quot;冬&quot;];</span><br><span class="line">let [a, b, c, d] &#x3D; jijie;</span><br><span class="line">console.log(a, b, c, d);</span><br></pre></td></tr></table></figure><p>2 .对象的解构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(&quot;testtest&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; name, age, fn &#125; &#x3D; obj;</span><br><span class="line">console.log(name);</span><br><span class="line">console.log(age);</span><br><span class="line">console.log(fn);</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>ES6 引入新的声明字符串的方式 <strong><code> </code></strong></p><p>特性：</p><ul><li>内容可以直接出现换行符</li><li>变量可以直接拼接 ${}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fistName &#x3D; &quot;Lee&quot;;</span><br><span class="line">let fullName &#x3D; &#96;$&#123;fistName&#125;Alfa&#96;;</span><br><span class="line">console.log(fullName);</span><br></pre></td></tr></table></figure><h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样更简洁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let objName &#x3D; &quot;lifa&quot;;</span><br><span class="line">let funTest &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;fnTest&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; let objSimplify&#x3D;&#123;</span><br><span class="line">&#x2F;&#x2F;     objName:objName,</span><br><span class="line">&#x2F;&#x2F;     funTest:funTest,</span><br><span class="line">&#x2F;&#x2F;     anotherFn:function()&#123;</span><br><span class="line">&#x2F;&#x2F;         console.log(&#39;another&#39;);</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">let objSimplify &#x3D; &#123;</span><br><span class="line">  objName,</span><br><span class="line">  funTest,</span><br><span class="line">  another()&#123;</span><br><span class="line">      console.log(another);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(objSimplify);</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用箭头（=&gt;）定义函数</p><p>特性：</p><p>1 .this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值，即便是 call 也不可改变 this 的指向</p><p>2 .不能作为构造函数实例化对象</p><p>3 .不能使用 arguments 对象</p><p>4 .箭头函数简写</p><ul><li><p>省略小括号，当形参有且只有一个的时候</p></li><li><p>省略花括号，当代码体只有一条语句的时候，此时 return 必须省略，而且语句执行的结果就是函数的返回值</p></li></ul><p>箭头函数适合与 this 无关的回调，定时器，数组的方法回调</p><p>箭头函数不适合与 this 有关的回调，事件回调，对象的方法</p><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>ES6 允许给函数参数赋值初始值</p><p>1 .形参初始值，具有默认值的参数，一般位置要靠后（潜规则）</p><p>2 .与解构赋值结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function connect(&#123; url &#x3D; &quot;127.0.0.1&quot;, host, username, port &#125;) &#123;</span><br><span class="line">  console.log(url);</span><br><span class="line">  console.log(host);</span><br><span class="line">  console.log(username);</span><br><span class="line">  console.log(port);</span><br><span class="line">&#125;</span><br><span class="line">connect(&#123;</span><br><span class="line">  host: &quot;atguigu.com&quot;,</span><br><span class="line">  username: &quot;root&quot;,</span><br><span class="line">  password: &quot;root&quot;,</span><br><span class="line">  port: 3306,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>ES6 引入<strong>rest</strong>参数，用于获取函数的实参，用来替代 arguments，arguments 不是数组，而 rest 是数组</p><p>注意：<em>rest 参数必须要放到参数最后</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5获取参数方式</span><br><span class="line">function date1() &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">date1(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, typeof arguments);&#x2F;&#x2F;[Arguments] &#123; &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, &#39;3&#39;: &#39;object&#39; &#125;</span><br><span class="line">&#x2F;&#x2F;ES6方式</span><br><span class="line">function date2(a, b, ...rest) &#123;</span><br><span class="line">  console.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">date2(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);&#x2F;&#x2F;[ &#39;cc&#39;, &#39;dd&#39; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="spread-扩展运算符"><a href="#spread-扩展运算符" class="headerlink" title="spread 扩展运算符"></a>spread 扩展运算符</h2><p>…扩展运算符能将<strong>数组(或伪数组)**转换为逗号分隔的</strong>参数序列**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const dir &#x3D; [&#39;东&#39;,&#39;南&#39;,&#39;西&#39;,&#39;北&#39;];</span><br><span class="line">function dirFn()&#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">dirFn(dir);&#x2F;&#x2F;[Arguments] &#123; &#39;0&#39;: [ &#39;东&#39;, &#39;南&#39;, &#39;西&#39;, &#39;北&#39; ] &#125;</span><br><span class="line">dirFn(...dir);&#x2F;&#x2F;[Arguments] &#123; &#39;0&#39;: &#39;东&#39;, &#39;1&#39;: &#39;南&#39;, &#39;2&#39;: &#39;西&#39;, &#39;3&#39;: &#39;北&#39; &#125;</span><br></pre></td></tr></table></figure><p>应用：</p><ul><li>数组合并</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [&quot;a&quot;, &quot;b&quot;];</span><br><span class="line">const arr2 &#x3D; [&quot;c&quot;, &quot;d&quot;];</span><br><span class="line">const fullArr1 &#x3D; arr1.concat(arr2); &#x2F;&#x2F;[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]</span><br><span class="line">console.log(fullArr1);</span><br><span class="line">const fullArr2 &#x3D; [...arr1, ...arr2]; &#x2F;&#x2F;[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]</span><br><span class="line">console.log(fullArr2);</span><br></pre></td></tr></table></figure><ul><li><p>数组克隆</p></li><li><p>将伪数组转换为真数组</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function spreadFn() &#123;</span><br><span class="line">  console.log(arguments);&#x2F;&#x2F;[Arguments] &#123; &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39; &#125;</span><br><span class="line">  console.log([...arguments]);&#x2F;&#x2F;[ &#39;a&#39;, &#39;b&#39; ]</span><br><span class="line">&#125;</span><br><span class="line">spreadFn(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>原始数据类型 Symbol，表示独一无二的值，第七种数据类型</p><ul><li><p>Symbol 特点</p><ul><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 值不能与其他数据进行运算</li><li>Symbol 定义的对象属性不能用 for…in 循环遍历，但可以使用 Reflect.ownKeys 来获取对象的所有键名</li></ul></li><li><p>创建 Symbol</p></li></ul><ol><li>Symbol()方式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Symbol();</span><br><span class="line">console.log(s, typeof s);</span><br><span class="line">let s1 &#x3D; Symbol(&quot;我是描述字符串&quot;);</span><br><span class="line">let s2 &#x3D; Symbol(&quot;我是描述字符串&quot;);</span><br><span class="line">console.log(s1 &#x3D;&#x3D; s2); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Symbol.for 创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let s3 &#x3D; Symbol.for(&quot;尚硅谷&quot;);</span><br><span class="line">let s4 &#x3D; Symbol.for(&quot;尚硅谷&quot;);</span><br><span class="line">let s5 &#x3D; Symbol.for(&quot;我是描述字符串&quot;);</span><br><span class="line">console.log(s3, typeof s3);</span><br><span class="line">console.log(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;true</span><br><span class="line">console.log(s3 &#x3D;&#x3D;&#x3D; s4);&#x2F;&#x2F;true</span><br><span class="line">console.log(s3 &#x3D;&#x3D; s5);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><ul><li>七种数据类型</li></ul><p>USONB–you are so niubility<br>u undefined</p><p>s——<em>string symbol</em></p><p>o——object</p><p>n——<em>null number</em></p><p>b——boolean</p><h2 id="Symbol-创建对象属性"><a href="#Symbol-创建对象属性" class="headerlink" title="Symbol 创建对象属性"></a>Symbol 创建对象属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  let game &#x3D; &#123;</span><br><span class="line">            up: function () &#123;</span><br><span class="line">                console.log(&quot;upup&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            down: function () &#123;</span><br><span class="line">                console.log(down);</span><br><span class="line">            &#125;,</span><br><span class="line">            [Symbol(&quot;left&quot;)]: function () &#123;&#x2F;&#x2F;此种方法如何调用？</span><br><span class="line">                console.log(&quot;left1&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            [Symbol.for(&#39;left&#39;)]: function () &#123;&#x2F;&#x2F;此种方法可以调用</span><br><span class="line">                console.log(&quot;left2&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; console.log(game[Symbol(&quot;left&quot;)]);</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">        let methods &#x3D; &#123;</span><br><span class="line">            up: Symbol(&quot;up&quot;),</span><br><span class="line">            down: Symbol(&quot;down&quot;),</span><br><span class="line">            left: Symbol(&quot;left&quot;),</span><br><span class="line">        &#125;;</span><br><span class="line">        game[methods.up] &#x3D; function () &#123;</span><br><span class="line">            console.log(&quot;up2&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        game[methods.down] &#x3D; function () &#123;</span><br><span class="line">            console.log(down2);</span><br><span class="line">        &#125;;</span><br><span class="line">        game[methods.left] &#x3D; function () &#123;</span><br><span class="line">            console.log(&quot;left3&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        console.log(game);</span><br><span class="line">        &#x2F;&#x2F; console.log(game[Symbol(&#39;left&#39;)]());</span><br><span class="line">        console.log(game[Symbol.for(&#39;left&#39;)]());</span><br></pre></td></tr></table></figure><h2 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h2><p>11 个内置的 Symbol 值，指向语言内部使用的方法,控制对象在特定场景下的表现</p><ul><li>Symbol.hasInstance</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Persong &#123;</span><br><span class="line">  static [Symbol.hasInstance](param) &#123;</span><br><span class="line">    console.log(param);</span><br><span class="line">    console.log(&quot;用来检测类型&quot;);</span><br><span class="line">    &#x2F;&#x2F; return true;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o &#x3D; &#123;&#125;;</span><br><span class="line">console.log(o instanceof Persong);</span><br></pre></td></tr></table></figure><ul><li>Symbol.isConcatSpreadable</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let symArr1 &#x3D; [&quot;1&quot;, &quot;2&quot;];</span><br><span class="line">let symArr2 &#x3D; [&quot;3&quot;, &quot;4&quot;, &quot;5&quot;];</span><br><span class="line">symArr2[Symbol.isConcatSpreadable] &#x3D; false;</span><br><span class="line">console.log(symArr1.concat(symArr2));&#x2F;&#x2F;[&quot;1&quot;, &quot;2&quot;, Array(3)]</span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）是一个接口，任何数据结构只要部署了<strong>Iterator 接口（即对象中的属性，Symbol.iterator）</strong>，就可以完成遍历操作。</p><ul><li><p>ES6 创造的新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。<strong>（for…in 遍历键名，for…of 遍历键值）</strong></p></li><li><p>原生具备 iterator 接口的数据（可用 for…of）：Array 、Arguments、Set、Map、String、TypedArray、NodeList</p></li><li><p>工作原理</p><ul><li><p>创建一个指针对象，指向当前数据结构的起始位置<br><img src="./imgs/iterator%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1.png" alt="avatar"></p></li><li><p>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p><p><img src="./imgs/iterator%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E4%B8%ADnext%E6%96%B9%E6%B3%95.png" alt="avatar"></p></li><li><p>接下来不断调用 next 方法，指针一直往后移动，知道指向最有一个成员</p></li><li><p>每次调用 next 方法返回一个包含 value 和 done 属性的对象</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let iteratorArr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line">console.log(iteratorArr);</span><br><span class="line">&#x2F;&#x2F;获取Symbol.iterator对应的函数，用以创建对象，在可遍历对象的_proto_上</span><br><span class="line">let iteratorFunction &#x3D; iteratorArr[Symbol.iterator];</span><br><span class="line">&#x2F;&#x2F;创建指针对象，使用Symbol.iterator对应的函数创建</span><br><span class="line">let iteratorObj &#x3D; iteratorArr[Symbol.iterator]();</span><br><span class="line">console.log(iteratorObj);</span><br><span class="line">&#x2F;&#x2F;指针对象上有next方法,调用</span><br><span class="line">console.log(iteratorObj.next());&#x2F;&#x2F;&#123;value: &quot;a&quot;, done: false&#125;</span><br><span class="line">console.log(iteratorObj.next());</span><br><span class="line">console.log(iteratorObj.next());</span><br><span class="line">console.log(iteratorObj.next());&#x2F;&#x2F;&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义迭代器遍历对象"><a href="#自定义迭代器遍历对象" class="headerlink" title="自定义迭代器遍历对象"></a>自定义迭代器遍历对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const iteratorData &#x3D; &#123;</span><br><span class="line">           name: &quot;二班&quot;,</span><br><span class="line">           students: [&quot;老二&quot;, &quot;雅兴&quot;, &quot;张超&quot;],</span><br><span class="line">           [Symbol.iterator]: function () &#123;</span><br><span class="line">               let index &#x3D; 0;</span><br><span class="line">               let _this &#x3D; this;</span><br><span class="line">               return &#123;</span><br><span class="line">                   next: function () &#123;</span><br><span class="line">                       if (index &lt; _this.students.length) &#123;</span><br><span class="line">                           const result &#x3D; &#123; value: _this.students[index], done: false &#125;;</span><br><span class="line">                           index++;</span><br><span class="line">                           return result;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           const result &#x3D; &#123; value: _this.students[index], done: true &#125;;</span><br><span class="line">                           return result;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;,</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;;</span><br><span class="line">       for (let v of iteratorData) &#123;</span><br><span class="line">           console.log(v);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><ul><li>迭代器对象信息<br><img src="./imgs/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0.png" alt="avatar"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  yield &quot;aaa&quot;;</span><br><span class="line">  yield &quot;bbb&quot;;</span><br><span class="line">  yield &quot;ccc&quot;;</span><br><span class="line">&#125;</span><br><span class="line">let iteratorGen &#x3D; gen();&#x2F;&#x2F;返回值为一个迭代器对象</span><br><span class="line">console.log(iteratorGen);</span><br><span class="line">console.log(iteratorGen.next()); &#x2F;&#x2F;&#123;value: &quot;aaa&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">for (const v of gen()) &#123;</span><br><span class="line">  console.log(v); &#x2F;&#x2F;aaa bbb ccc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器函数参数"><a href="#生成器函数参数" class="headerlink" title="生成器函数参数"></a>生成器函数参数</h2><ul><li>函数传参和 next 方法传参，两种方式</li><li><strong><em>第一个 next 方法传递的参数不可输出，第二个 next 方法参数将作为第一个 yield 返回结果值</em></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* gen2(arg)&#123;</span><br><span class="line">  console.log(arg);&#x2F;&#x2F;AAA</span><br><span class="line">  let one &#x3D; yield &#39;111&#39;;</span><br><span class="line">  console.log(one);&#x2F;&#x2F;BBB</span><br><span class="line">  let two &#x3D; yield &#39;222&#39;;</span><br><span class="line">  console.log(two);&#x2F;&#x2F;CCC</span><br><span class="line">  let three &#x3D; yield &#39;333&#39;</span><br><span class="line">  console.log(three);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行获取迭代器对象</span><br><span class="line">let paramGen &#x3D; gen2(&quot;AAA&quot;);</span><br><span class="line">console.log(paramGen.next(&#39;EEE&#39;));&#x2F;&#x2F;无输出</span><br><span class="line">console.log(paramGen.next(&#39;BBB&#39;));&#x2F;&#x2F;next方法可以传入参数，BBB作为第一个yield返回结果</span><br><span class="line">console.log(paramGen.next(&#39;CCC&#39;));&#x2F;&#x2F;CCC将作为第二个yield返回结果</span><br><span class="line">console.log(paramGen.next(&#39;DDD&#39;));</span><br></pre></td></tr></table></figure><h2 id="生成器实例"><a href="#生成器实例" class="headerlink" title="生成器实例"></a>生成器实例</h2><p>1 .回调地狱问题</p><ul><li>js 异步编程 文件操作 网络操作 数据库操作</li><li>解决回调地狱问题<ul><li>将异步任务放到 yield 语句后执行，调用 next 方法执行 yield 语句</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function one()&#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">    iteratorHell.next();</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function two(params) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(222);</span><br><span class="line">    iteratorHell.next();</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line">function three(params) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(333);</span><br><span class="line">    &#x2F;&#x2F; iterator.next();</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line">function* dealHellFun(params) &#123;</span><br><span class="line">  yield one();</span><br><span class="line">  yield two();</span><br><span class="line">  yield three();</span><br><span class="line">&#125;</span><br><span class="line">let iteratorHell &#x3D; dealHellFun();</span><br><span class="line">iteratorHell.next();</span><br></pre></td></tr></table></figure><p>2 .模拟数据获取 用户数据 订单数据 商品数据</p><ul><li>数据是有关联的，要先有用户，根据用户获取订单，在获取商品数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function getUser(params) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    let data &#x3D; &#39;用户数据&#39;;</span><br><span class="line">    iteratorMall.next(data);&#x2F;&#x2F;第二次调用next，传入的参数做为第一个yield语句返回结果</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function getOrders(params) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    let data &#x3D; &#39;订单数据&#39;;</span><br><span class="line">    iteratorMall.next(data);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function getGoods(params) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    let data &#x3D; &#39;商品数据&#39;;</span><br><span class="line">    iteratorMall.next(data);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">function* gen3()&#123;</span><br><span class="line">  let user &#x3D; yield getUser();</span><br><span class="line">  console.log(user);</span><br><span class="line">  let orders &#x3D; yield getOrders();</span><br><span class="line">  console.log(orders);</span><br><span class="line">  let goods &#x3D; yield getGoods();</span><br><span class="line">  console.log(goods);</span><br><span class="line">&#125;</span><br><span class="line">let iteratorMall &#x3D; gen3();</span><br><span class="line">iteratorMall.next();</span><br></pre></td></tr></table></figure><h1 id="Promise-基本语法"><a href="#Promise-基本语法" class="headerlink" title="Promise 基本语法"></a>Promise 基本语法</h1><p>Promise 是 ES6 引入的异步编程的新解决方案。<strong><em>语法上 Promise 是一个构造函数</em></strong>，用来封装异步操作并可以获取其成功或失败的结果。</p><ul><li><p>Promise 构造函数：Promise（excutor）{}</p></li><li><p>Promise.prototype.then 方法</p></li><li><p>Promise.prototype.catch 方法</p></li></ul><ol><li>Promise 封装 Ajax</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">           &#x2F;&#x2F;1.创建对象</span><br><span class="line">           let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">           &#x2F;&#x2F;2.初始化</span><br><span class="line">           xhr.open(&quot;get&quot;, &quot;https:&#x2F;&#x2F;api.apiopen.top&#x2F;getJoke&quot;);</span><br><span class="line">           &#x2F;&#x2F;3.发送</span><br><span class="line">           xhr.send();</span><br><span class="line">           &#x2F;&#x2F;4.绑定事件，处理相应结果</span><br><span class="line">           xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">               if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">                   if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">                       resolve(xhr.response);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;);</span><br><span class="line">       p.then(value &#x3D;&gt; &#123;</span><br><span class="line">           console.log(value);</span><br><span class="line">       &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">           console.log(err);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>Promise 的 then 方法</li></ol><ul><li><p>then 方法的返回结果也是 Promise 对象，对象状态由回调函数执行结果决定</p><ul><li><p>如果 then 方法回调函数中返回的结果是<strong><em>非 Promise 类型的属性，then 返回的 promise 对象的状态为成功</em></strong>，返回值为对象的成功的值(<strong><em>即 resolve 函数传入的值</em></strong>)</p></li><li><p>如果 then 方法回调函数中返回结果是<strong><em>Promise 对象，then 返回的 promise 对象的状态为返回的 promise 对象的状态</em></strong>，返回值为返回的 promise 对象 then 方法返回的值(resolve 函数参数的值)</p></li><li><p>如果 then 方法回调函数中返回结果是<strong><em>抛出错误，then 返回的 promise 对象的状态为 rejected</em></strong>，返回值为抛出错误的值</p></li></ul></li><li><p>then 方法可以链式调用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(success&#x3D;&gt;&#123;&#125;,err&#x3D;&gt;&#123;&#125;).then()</span><br></pre></td></tr></table></figure><ul><li>读取多个文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">const &#123; resolve &#125; &#x3D; require(&quot;path&quot;);</span><br><span class="line">var readPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  fs.readFile(&quot;.&#x2F;data&#x2F;readfile1.txt&quot;, function (err, data1) &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(data1.toString());</span><br><span class="line">    resolve(data1);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">readPromise</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      fs.readFile(&quot;.&#x2F;data&#x2F;readfile2.txt&quot;, function (err, data2) &#123;</span><br><span class="line">        resolve([value, data2]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((value) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&quot;.&#x2F;data&#x2F;readfile3.txt&quot;, function (err, data3) &#123;</span><br><span class="line">      value.push(data3);</span><br><span class="line">      console.log(value.join(&quot;\r\n&quot;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6 提供新的数据结构 Set（集合）。它类似于数组，但<strong><em>成员的值都是唯一的</em></strong>，集合实现了 iterator 接口，所以可以使用扩展运算符和 for…of…进行遍历。</p><p>1 .集合的属性和方法：</p><ul><li>size 返回集合的元素个数</li><li>add 增加一个新元素，返回当前集合</li><li>delete 删除元素，返回 bool 值</li><li>has 检测集合中是否包含某个元素，返回 bool 值</li><li>clear 清空集合</li></ul><p>2 .应用</p><ul><li>数组去重</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let setArr1 &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line">let newArr1 &#x3D; [...new Set(setArr1)];</span><br><span class="line">console.log(newArr1);</span><br></pre></td></tr></table></figure><ul><li>交集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let setArr2 &#x3D; [4,5,6,5,4];</span><br><span class="line">let unionArr &#x3D; [...new Set(setArr1)].filter(item&#x3D;&gt;&#123;</span><br><span class="line">  return new Set(setArr2).has(item);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(unionArr);</span><br></pre></td></tr></table></figure><ul><li>并集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result &#x3D; [...new Set([...setArr1,...setArr2])];</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><ul><li>差集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let diffArr &#x3D; [...new Set(setArr1)].filter(item &#x3D;&gt; !(new Set(setArr2).has(item)));</span><br><span class="line">console.log(diffArr);&#x2F;&#x2F;[ 1, 2, 3 ]</span><br><span class="line">let diffArr2 &#x3D; [...new Set(setArr2)].filter(item&#x3D;&gt;new Set(setArr1).has(item));</span><br><span class="line">console.log(diffArr2);</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ES6 提供了 Map 数据结构。</p><ul><li>类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种各类型的值（包括对象）都可以当做键。</li><li>Map 也实现了 iterator 接口，所以可以使用扩展运算符和 for…of 进行遍历</li></ul><p>Map 的属性和方法：</p><ul><li>size 返回 Map 元素的个数</li><li>set 增加一个新元素，返回当前 Map</li><li>get 返回简明对象的键值</li><li>has 检测 Map 中是否包含某个元素，返回 bool 值</li><li>clear 清空结合，返回 undefined</li></ul><h1 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h1><p>作为对象模板，通过 class 关键字，可以定义类。</p><ul><li>基本上，ES6 的 class 可以看做知识一个语法糖，他的绝大部分功能，ES5 都可以做到。</li><li>新的 class 写法只是让对象原型的写法更加清晰、更像面向对象的语法而已。</li></ul><ol><li>类定义</li></ol><ul><li>构造方法，名字必须为 constructor，不可修改</li><li>方法必须使用 ES6 方法，不能使用 ES5 的对象完整形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Phone &#123;</span><br><span class="line">  constructor(brand, price) &#123;</span><br><span class="line">    this.brand &#x3D; brand,</span><br><span class="line">    this.price &#x3D; price;</span><br><span class="line">  &#125;</span><br><span class="line">  call()&#123;</span><br><span class="line">    console.log(&#39;打电话&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let phone &#x3D; new Phone(&#39;Iphone&#39;,&#39;5毛&#39;);</span><br><span class="line">console.log(phone);</span><br></pre></td></tr></table></figure><ol start="2"><li>class 静态成员</li></ol><p><strong><em>函数是一个对象，[函数名]为函数对象；[new 函数名]获得的对象是实例对象</em></strong></p><p>属于函数对象而不属于实例对象的属性和方法，称之为静态成员。则<strong><em>静态成员属于类不属于实例对象</em></strong></p><ol><li>ES5 方式实例对象</li></ol><ul><li>实例对象和函数对象是不同的，属性和方法是不通的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MPhone是函数对象，mPhone是实例对象</span><br><span class="line">function MPhone()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MPhone.name &#x3D; &#39;小米&#39;;</span><br><span class="line">MPhone.call &#x3D; function()&#123;</span><br><span class="line">  console.log(&#39;Hello mi fans&#39;);</span><br><span class="line">&#125;</span><br><span class="line">let mPhone&#x3D; new MPhone();</span><br><span class="line">&#x2F;&#x2F;对象上没有构造函数上的属性方法</span><br><span class="line">console.log(mPhone.name);&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure><ul><li>实例对象和<em>构造函数原型</em>对象是相通的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function MPhone()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MPhone.prototype.name &#x3D; &#39;小米&#39;;&#x2F;&#x2F;给构造函数上添加属性</span><br><span class="line">MPhone.prototype.call &#x3D; function()&#123;</span><br><span class="line">  console.log(&#39;Hello mi fans&#39;);</span><br><span class="line">&#125;</span><br><span class="line">let mPhone&#x3D; new MPhone();</span><br><span class="line">console.log(mPhone.name);&#x2F;&#x2F;小米</span><br></pre></td></tr></table></figure><ol start="2"><li>ES6 中 class 静态成员</li></ol><p><em>静态成员属于类不属于实例对象</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> class StaticPhone&#123;</span><br><span class="line">  static name &#x3D; &#39;shouji&#39;;</span><br><span class="line">  static change()&#123;</span><br><span class="line">    console.log(&#39;static方法&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let nokia &#x3D; new StaticPhone();</span><br><span class="line">console.log(nokia.name);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(StaticPhone.name);&#x2F;&#x2F;手机</span><br></pre></td></tr></table></figure><ol start="3"><li>对象继承</li></ol><ul><li>ES5 使用构造函数实现对象继承</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父级</span><br><span class="line">function MPhone(brand, price) &#123;</span><br><span class="line"> this.brand &#x3D; brand;</span><br><span class="line"> this.price &#x3D; price;</span><br><span class="line">&#125;</span><br><span class="line">MPhone.prototype.call3 &#x3D; function () &#123;</span><br><span class="line"> console.log(&quot;打电话&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;子级</span><br><span class="line">function SmartPhone(brand, price, color, size) &#123;</span><br><span class="line"> &#x2F;&#x2F;调用父级构造函数初始化代码,避免代码重写</span><br><span class="line"> MPhone.call(this, brand, price);</span><br><span class="line"> this.color &#x3D; color;</span><br><span class="line"> this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;设置子级构造函数原型</span><br><span class="line">SmartPhone.prototype &#x3D; new MPhone(); &#x2F;&#x2F;实例对象和构造函数原型上的属性方法是相通的</span><br><span class="line">SmartPhone.prototype.constructor &#x3D; SmartPhone;</span><br><span class="line">&#x2F;&#x2F;声明子级的方法(注意：实例上并不会出现此方法)</span><br><span class="line">SmartPhone.photo1 &#x3D; function () &#123;</span><br><span class="line"> console.log(&quot;函数对象（父级）方法&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;声明子级实例的方法</span><br><span class="line">SmartPhone.prototype.photo &#x3D; function () &#123;</span><br><span class="line"> console.log(&quot;实例对象（子级）方法&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;实例化</span><br><span class="line">const hammer &#x3D; new SmartPhone(&quot;锤子&quot;, 3333, &quot;黑色&quot;, &quot;5inch&quot;);</span><br><span class="line">console.log(hammer);</span><br></pre></td></tr></table></figure><p><img src="./imgs/ES5%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF.png" alt="avatar"></p><ul><li><p>ES6 中 class 对象继承</p><ul><li>继承方式：class 子类名 <strong><em>extends</em></strong> 父类名{}</li><li>子类中添加 super()函数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class FatherClass &#123;</span><br><span class="line">  constructor(brand, price) &#123;</span><br><span class="line">    this.brand &#x3D; brand;</span><br><span class="line">    this.price &#x3D; price;</span><br><span class="line">  &#125;</span><br><span class="line">  call3() &#123;</span><br><span class="line">    console.log(&#39;class父级方法&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SonClass extends FatherClass &#123;</span><br><span class="line">  constructor(brand, price, color, size) &#123;</span><br><span class="line">    super(brand, price);</span><br><span class="line">    this.color &#x3D; color;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">  &#125;</span><br><span class="line">  sonFun() &#123;</span><br><span class="line">    console.log(&#39;子类的方法&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let sonClass &#x3D; new SonClass(&#39;iPhone&#39;, 333, &#39;星空灰&#39;, &#39;4inch&#39;);</span><br><span class="line">console.log(sonClass);</span><br></pre></td></tr></table></figure><p><img src="./imgs/ES6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF.png" alt="avatar"></p><ol start="3"><li>子类对父类方法的重写</li></ol><ul><li>子类不可以直接调用父类同名方法，super 方法只能出现在 constructor</li></ul><ol start="4"><li>class 中 getter 和 setter</li></ol><ul><li>get 通常对对象的动态属性进行封装</li><li>set 添加更多的控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class GetSetClass &#123;</span><br><span class="line">  get price() &#123;</span><br><span class="line">    console.log(&#39;获取价格&#39;);</span><br><span class="line">    return &#39;huoqu&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  set price(newVal) &#123;</span><br><span class="line">    console.log(&#39;价格修改&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let getSetClass &#x3D; new GetSetClass();</span><br><span class="line">console.log(getSetClass.price);</span><br><span class="line">getSetClass.price &#x3D; &#39;124&#39;</span><br></pre></td></tr></table></figure><h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1><ol><li><p>Number.EPSILON 是 JavaScript 表示的最小精度，接近 2.22E-16</p></li><li><p>二进制和八进制</p><ul><li>二进制 0b 开头，八进制 0o 开头，十六进制 ox 开头</li></ul></li><li><p>Number.isFinite 检测一个数值是否为有限数</p></li><li><p>Number.inNaN 检测一个数值是否为有限数</p></li><li><p>Number.parsInt Number.parseFloat 字符串转换</p></li><li><p>Number.isInteger 判断一个数是否为整数</p></li><li><p>Math.trunc 将数字的小鼠部分抹掉</p></li><li><p>Math.sign 判断一个数到底为正数 负数 还是零</p></li></ol><h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><ol><li>Object.is 判断两个值是否完全相等</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN&#x3D;&#x3D;&#x3D;NaN);&#x2F;&#x2F;false</span><br><span class="line">console.log(Object.is(NaN,NaN));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Object.assign 对象的合并</p></li><li><p>Object.setPrototypeof 设置原型对象 Object.getPrototypeof</p></li></ol><h1 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h1><p>模块化是将一个大的程序文件，拆分成许多小的文件,然后将小文件组合起来.</p><p>优点：</p><ul><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ul><h2 id="模块化规范产品"><a href="#模块化规范产品" class="headerlink" title="模块化规范产品"></a>模块化规范产品</h2><ul><li>CommonJS—&gt;Node Browserify</li><li>AMD —&gt; requireJS</li><li>CMD —&gt; seaJS</li><li>ES6 规范 —&gt; 浏览器端规范</li></ul><h2 id="ES6-模块化语法"><a href="#ES6-模块化语法" class="headerlink" title="ES6 模块化语法"></a>ES6 模块化语法</h2><p>模块功能主要由两个命令构成：export 和 import</p><ul><li>export 命令用于规定模块的对外接口</li><li>import 命令 用于输入其他模块提供的功能(<strong><em>html 中引入时要设置 script 标签的 type 属性为 module</em></strong>)</li></ul><p>一、export 暴露方式：</p><ol><li>分别暴露</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export let name1 &#x3D; &#39;分别暴露方式&#39;;</span><br><span class="line">export function exportFun1()&#123;</span><br><span class="line">    console.log(&#39;分别暴露方式函数&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./imgs/es6%E6%A8%A1%E5%9D%97%E5%8C%96/%E5%88%86%E5%88%AB%E6%9A%B4%E9%9C%B2.png" alt="avatar"></p><ol start="2"><li>统一暴露</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name1 &#x3D; &#39;分别暴露方式2&#39;;</span><br><span class="line">function exportFun1()&#123;</span><br><span class="line">    console.log(&#39;分别暴露方式函数2&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;name1,exportFun1&#125;</span><br></pre></td></tr></table></figure><p><img src="./imgs/es6%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%9F%E4%B8%80%E6%9A%B4%E9%9C%B2.png" alt="avatar"></p><ol start="3"><li>默认暴露</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name1: &quot;default暴露方式&quot;,</span><br><span class="line">  exportFun1: function () &#123;</span><br><span class="line">    console.log(&quot;default暴露方式&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="./imgs/es6%E6%A8%A1%E5%9D%97%E5%8C%96/default.png" alt="avatar"></p><p>二、引入模块</p><ol><li>通用导入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as m1 from &#39;.&#x2F;js&#x2F;export1.js&#39;&#x2F;&#x2F;通用的引入方式</span><br></pre></td></tr></table></figure><ol start="2"><li>解构赋值形式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分别导出的引入</span><br><span class="line">import &#123;name1,exportFun1&#125; from &#39;.&#x2F;js&#x2F;export1.js&#39;&#x2F;&#x2F;解构赋值方式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统一导出的引入</span><br><span class="line">import &#123;name1 as name,exportFun1 as fun&#125; from &#39;.&#x2F;js&#x2F;export2.js&#39;&#x2F;&#x2F;设置别名解决命名冲突</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;default导出的引入</span><br><span class="line">import &#123;default as m3&#125; from &#39;.&#x2F;js&#x2F;export3.js&#39;</span><br></pre></td></tr></table></figure><ol start="3"><li>简便形式，只能针对默认暴露</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import m4 from &#39;.&#x2F;js&#x2F;export3.js&#39;&#x2F;&#x2F;简便形式，只适合default导出的</span><br></pre></td></tr></table></figure><h2 id="ES6-浏览器使用-ES6-模块化方式"><a href="#ES6-浏览器使用-ES6-模块化方式" class="headerlink" title="ES6-浏览器使用 ES6 模块化方式"></a>ES6-浏览器使用 ES6 模块化方式</h2><ol><li><p>直接导入方式</p></li><li><p>–&gt;app.js 方式</p></li></ol><p>在 app.js 文件引入各个模块文件，然后在 html 文件中引入 app.js 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.js</span><br><span class="line">  import * as m1 from &#39;.&#x2F;export1.js&#39;&#x2F;&#x2F;通用的引入方式</span><br><span class="line">  import &#123; name1 as name, exportFun1 as fun &#125; from &#39;.&#x2F;export2.js&#39;</span><br><span class="line">  import &#123; default as m3 &#125; from &#39;.&#x2F;export3.js&#39;</span><br><span class="line">  import m4 from &#39;.&#x2F;export3.js&#39;&#x2F;&#x2F;简便形式，只适合default导出的</span><br><span class="line"></span><br><span class="line">  console.log(m1);</span><br><span class="line">  console.log(name);</span><br><span class="line">  console.log(m3);</span><br><span class="line">  console.log(m4);</span><br></pre></td></tr></table></figure><ol start="3"><li>–&gt;Babel 方式（ES6→ES5）</li></ol><ul><li>并非所有的浏览器支持 ES6 语法</li><li>ES6 模块化还不能对 npm 安装的模块进行导入</li></ul><p>步骤：</p><ol><li><p>安装工具 babel-cli（babel 命令行工具）、 babel-preset-env(预设包，把最新的 ES 特性转换为 ES5)、 browserify(webpack)</p></li><li><p>语法转换 npx babel 源文件目录 -d dist/js –preset=babel-preset-env</p><ul><li>ES6 语法转换为 CommonJS 模块规范化语法</li><li>浏览器不识别 require 语法</li></ul></li><li><p>打包 npx browserify dist/js -o dist/bundle.js</p></li></ol><h1 id="ECMAScript7-新特性"><a href="#ECMAScript7-新特性" class="headerlink" title="ECMAScript7 新特性"></a>ECMAScript7 新特性</h1><ol><li><p>Array.prototype.includes</p><p>includes 方法用于检测数组中是否包含某个元素，返回布尔类型值</p></li><li><p>指数运算符</p><p>在 ES7 中引入指数运算符“**”，用来实现幂运算，功能与 Math.pow 结果相同</p></li></ol><h1 id="ECMAScript8-新特性"><a href="#ECMAScript8-新特性" class="headerlink" title="ECMAScript8 新特性"></a>ECMAScript8 新特性</h1><p>async 和 await 两种语法相结合可以让异步代码像同步代码一样</p><ol><li><strong>async 函数</strong></li></ol><ul><li>async 函数的返回值为 promise 对象，此对象由此函数内部 return 的状态决定</li><li>promise 对象的结果由 async 函数执行的返回结果决定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function asyncTest() &#123;</span><br><span class="line">  &#x2F;&#x2F;返回结果不是一个promise类型的对象，返回的结果就是成功Promise对象</span><br><span class="line">  &#x2F;&#x2F; return;&#x2F;&#x2F;状态成功</span><br><span class="line">  &#x2F;&#x2F;返回一个字符串</span><br><span class="line">  &#x2F;&#x2F; return &#39;async函数&#39;;&#x2F;&#x2F;状态成功</span><br><span class="line">  &#x2F;&#x2F;抛出错误，返回的结果是一个失败的Promise</span><br><span class="line">  &#x2F;&#x2F; throw new Error(&#39;出错啦&#39;);&#x2F;&#x2F;状态失败</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; resolve(&#39;状态成功&#39;);&#x2F;&#x2F;指此promise对象状态成功，则async函数状态成功</span><br><span class="line">    reject(&quot;状态失败&quot;);&#x2F;&#x2F;意味着此promise对象状态失败，则async函数状态失败</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">let asyncResult &#x3D; asyncTest();</span><br><span class="line">console.log(asyncResult);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>await 表达式</strong></li></ol><ul><li>await 必须写在 async 函数中</li><li>await 右侧的表达式一般为 promise 对象</li><li>await 返回的是 promise 对象成功的值</li><li>await 的 promise 失败了，就会抛出异常，需要通过 try…catch 捕获处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let awaitPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; resolve(&#39;await后面一般为promise对象&#39;);</span><br><span class="line">  reject(&#39;失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;await函数写在async中</span><br><span class="line">async function awaitFun() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      let result &#x3D; await awaitPromise;</span><br><span class="line">      console.log(&#39;await返回的是promise对象成功的值：&#39;);</span><br><span class="line">      console.log(result);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">awaitFun();</span><br></pre></td></tr></table></figure><ol start="3"><li>async 和 await 集合读取文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">function getFile1() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&quot;.&#x2F;data&#x2F;readfile1.txt&quot;, function (err, data1) &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(data1.toString());</span><br><span class="line">      if(err) reject(err)</span><br><span class="line">      resolve(data1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> function getFile2() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&quot;.&#x2F;data&#x2F;readfile2.txt&quot;, function (err, data1) &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(data1.toString());</span><br><span class="line">      if(err) reject(err)</span><br><span class="line">      resolve(data1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">function getFile3() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    fs.readFile(&quot;.&#x2F;data&#x2F;readfile3.txt&quot;, function (err, data1) &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(data1.toString());</span><br><span class="line">      if(err) reject(err)</span><br><span class="line">      resolve(data1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function getAllContent() &#123;</span><br><span class="line">  let data1 &#x3D; await getFile1();</span><br><span class="line">  let data2 &#x3D; await getFile2();</span><br><span class="line">  let data3 &#x3D; await getFile3();</span><br><span class="line"></span><br><span class="line">  console.log(data1.toString());</span><br><span class="line">  console.log(data2.toString());</span><br><span class="line">  console.log(data3.toString());</span><br><span class="line">&#125;</span><br><span class="line">getAllContent();</span><br></pre></td></tr></table></figure><ol start="4"><li>async 和 await 结合封装 Ajax</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; var XMLHttpRequest &#x3D; require(&quot;xmlhttprequest&quot;).XMLHttpRequest;</span><br><span class="line">    &#x2F;&#x2F;1.创建对象</span><br><span class="line">    let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    &#x2F;&#x2F;2.初始化</span><br><span class="line">    xhr.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;api.apiopen.top&#x2F;getJoke&quot;);</span><br><span class="line">    &#x2F;&#x2F;3.发送</span><br><span class="line">    xhr.send();</span><br><span class="line">    &#x2F;&#x2F;4.绑定事件，处理相应结果</span><br><span class="line">    xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">          resolve(xhr.response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;promise then 方式</span><br><span class="line">&#x2F;&#x2F; getData().then(value&#x3D;&gt;&#123;console.log(value);&#125;,reason&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;     console.log(reason);</span><br><span class="line">&#x2F;&#x2F; &#125;);</span><br><span class="line">async function main() &#123;</span><br><span class="line">  let result &#x3D; await getData();</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="ES8-对象方法扩展"><a href="#ES8-对象方法扩展" class="headerlink" title="ES8 对象方法扩展"></a>ES8 对象方法扩展</h1><ol><li><p>Object.values()方法返回一个给定对象的所有可枚举属性值的数组</p></li><li><p>Object.entries()方法返回一个给定对象自身可遍历属性[key,value]的数组</p></li><li><p>Object.getOwnPropertyDescriptors()方法返回指定对象所有自身属性的描述对象</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const es8Obj &#x3D; &#123;</span><br><span class="line">  url:&#39;2.2.2.2&#39;,</span><br><span class="line">  method:&#39;get&#39;,</span><br><span class="line">  host:&#39;localhost&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(es8Obj));</span><br><span class="line">console.log(Object.values(es8Obj));</span><br><span class="line">console.log(Object.entries(es8Obj));</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(es8Obj));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ES9-扩展运算符与-rest-参数"><a href="#ES9-扩展运算符与-rest-参数" class="headerlink" title="ES9 扩展运算符与 rest 参数"></a>ES9 扩展运算符与 rest 参数</h1><ul><li>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对数组。</li><li>在 ES9 在为对象提供了像数组一样的 rest 参数和扩展运算符</li></ul><h1 id="ES9-正则扩展"><a href="#ES9-正则扩展" class="headerlink" title="ES9 正则扩展"></a>ES9 正则扩展</h1><h2 id="命名捕获分组"><a href="#命名捕获分组" class="headerlink" title="命名捕获分组"></a>命名捕获分组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let url &#x3D; &#39;&lt;a href&#x3D;&quot;https:baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">let reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(.*)&quot;&gt;(.*)&lt;\&#x2F;a&gt;&#x2F;;</span><br><span class="line">let result &#x3D; reg.exec(url);</span><br><span class="line">console.log(result);</span><br><span class="line">console.log(result[0]);</span><br><span class="line">console.log(result[1]);</span><br><span class="line">console.log(result[2]);</span><br><span class="line"></span><br><span class="line">let reg2 &#x3D; &#x2F;&lt;a href&#x3D;&quot;(?&lt;str&gt;.*)&quot;&gt;(?&lt;name&gt;.*)&lt;\&#x2F;a&gt;&#x2F;;</span><br><span class="line">let result2 &#x3D; reg2.exec(url);</span><br><span class="line">console.log(result2);</span><br><span class="line">console.log(result2.groups.str);</span><br><span class="line">console.log(result2[1]);</span><br></pre></td></tr></table></figure><p><img src="./imgs/reg2.png" alt="avatar"></p><p><img src="./imgs/reg1.png" alt="avatar"></p><h2 id="反向断言"><a href="#反向断言" class="headerlink" title="反向断言"></a>反向断言</h2><p>根据目标前后内容做唯一性识别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;JS1234你知道么555啦啦啦&quot;;&#x2F;&#x2F;匹配555</span><br><span class="line">let reg &#x3D; &#x2F;\d+(?&#x3D;啦)&#x2F;;</span><br><span class="line">let result &#x3D; reg.exec(str);</span><br><span class="line">console.log(result);&#x2F;&#x2F;555</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反向断言</span><br><span class="line">let reg2 &#x3D; &#x2F;(?&lt;&#x3D;么)\d+&#x2F;</span><br><span class="line">console.log(reg2.exec(str));&#x2F;&#x2F;555</span><br></pre></td></tr></table></figure><h2 id="dotAll-模式"><a href="#dotAll-模式" class="headerlink" title="dotAll 模式"></a>dotAll 模式</h2><p>dot . 元字符–&gt;匹配处换行符之外的任意字符</p><p>dotAll 模式使.可以匹配任意字符</p><h1 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h1><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><ul><li>传入二维数组,创建对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [[&#39;a&#39;,&#39;es10学习&#39;],[&#39;b&#39;,&#39;es10对象扩展&#39;]];</span><br><span class="line">let es10Obj &#x3D; Object.fromEntries(arr);</span><br><span class="line">console.log(es10Obj);&#x2F;&#x2F;&#123; a: &#39;es10学习&#39;, b: &#39;es10对象扩展&#39; &#125;</span><br></pre></td></tr></table></figure><ul><li>传入 Map</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">map.set(&quot;name&quot;, &quot;aaa&quot;);</span><br><span class="line">let e &#x3D; Object.fromEntries(map);</span><br><span class="line">console.log(e); &#x2F;&#x2F;&#123;name:&#39;aaa&#39;&#125;</span><br><span class="line">&#x2F;&#x2F;fromEntries与entries逆操作</span><br><span class="line">console.log(Object.entries(e)); &#x2F;&#x2F;[&#39;name&#39;,&#39;aaa&#39;]</span><br></pre></td></tr></table></figure><h2 id="trimStart-与-trimEnd"><a href="#trimStart-与-trimEnd" class="headerlink" title="trimStart 与 trimEnd"></a>trimStart 与 trimEnd</h2><p>用以清除字符前后的空白</p><h2 id="flat-与-flatMap"><a href="#flat-与-flatMap" class="headerlink" title="flat 与 flatMap"></a>flat 与 flatMap</h2><p>数组的两个方法</p><ul><li>flat 将多为数组转换为低维数组,参数为整数，表示深度，默认值为 1</li><li>flatMap()数组的方法，与 Array.map 类似，可以将遍历的 item 返回的结果降低维度</li></ul><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>获取 Symbol 函数参数值</p><h1 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h1><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>对属性的封装，私有属性用“#”标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  &#x2F;&#x2F;公有属性</span><br><span class="line">  name;</span><br><span class="line">  &#x2F;&#x2F;私有属性</span><br><span class="line">  #age;</span><br><span class="line">  #weight;</span><br><span class="line">  constructor(name,age,weight)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.#age &#x3D; age;</span><br><span class="line">    this.#weight &#x3D; weight;</span><br><span class="line">  &#125;</span><br><span class="line">  intro()&#123;</span><br><span class="line">    console.log(this.#age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let person &#x3D; new Person(&#39;aa&#39;,13,22)</span><br><span class="line">console.log(person.intro());</span><br><span class="line">&#x2F;&#x2F; console.log(person.#age);&#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure><h2 id="Promise-批处理方法"><a href="#Promise-批处理方法" class="headerlink" title="Promise 批处理方法"></a>Promise 批处理方法</h2><ol><li>Promise.allSettled()</li></ol><ul><li>接收 Promise 数组，返回 Promise 对象</li><li>返回的结果永远是成功的状态，结果为每一个 promise 状态和结果值</li></ul><ol start="2"><li>Promise.all()</li></ol><ul><li>接收 Promise 数组</li><li>返回结果由数组中每一个 promise 状态决定，全成功才成功</li></ul><h2 id="字符串扩展方法-matchAll"><a href="#字符串扩展方法-matchAll" class="headerlink" title="字符串扩展方法 matchAll"></a>字符串扩展方法 matchAll</h2><p>String.prototype.matchAll 用来得到正则批量匹配得到的结果</p><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><ul><li><p>形式：?.的组合</p></li><li><p>对象类型参数层级比较深，此符号可避免层层判断</p></li></ul><h2 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import"></a>动态 import</h2><p>实现按需加载</p><p>import()函数，传入资源路径，返回结果为 promise 对象</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>用于大整数数值运算</p><ul><li>在普通数字后加一个 n 即为大整型</li><li>转换为此类型方法 BigInt(),只能传入整数</li><li>不能与普通整数做运算，需要把普通整数转换为 BigInt 类型</li></ul><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>全局的 this，始终指向全局对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建简单步骤</title>
      <link href="2021/01/28/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/"/>
      <url>2021/01/28/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客搭建及部署简单步骤"><a href="#Hexo-博客搭建及部署简单步骤" class="headerlink" title="Hexo 博客搭建及部署简单步骤"></a><strong>Hexo 博客搭建及部署简单步骤</strong></h1><h2 id="一、博客项目搭建"><a href="#一、博客项目搭建" class="headerlink" title="一、博客项目搭建"></a>一、博客项目搭建</h2><ol><li><p>安装 Node 环境</p></li><li><p>安装 hexo 博客脚手架</p></li><li><p>博客项目初始化</p><ul><li>新建本地文件夹如 blog</li></ul><ul><li>在此文件夹启动命令行</li></ul><ul><li>输入 hexo init</li></ul></li><li><p>博客项目启动</p><ul><li>在 blog 文件夹下的命令行输入 hexo serve 或 hexo s</li></ul></li></ol><h2 id="二、部署到-Github"><a href="#二、部署到-Github" class="headerlink" title="二、部署到 Github"></a>二、部署到 Github</h2><ol><li><p>新建 github 账号</p></li><li><p>配置 SSH Key</p><p>① 设置 git 的 user name 和 email</p><ul><li>git config –global user.name “自己的 git 用户名”</li><li>git config –global user.email “自己的 git 邮箱”</li></ul><p>② 检查是否存在 SSH Key</p><ul><li>查看 C:\Users\计算机名.ssh 中是否有 id_rsa 和 id_rsa.pub</li></ul><p>③ 如果没有 SSH Key，则生成</p><ul><li>ssh-keygen -t rsa -C “个人 git 邮箱”</li></ul><p>④ 获取 SSH Key</p><ul><li>打开 id_rsa.pub 并复制</li></ul><p>⑤ GitHub 账户添加 SSH Key</p><ul><li>在 setting 中的 SSH and GPG Keys 中新建 SSH Key</li></ul><p>⑥ 验证</p><ul><li>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a></li></ul></li><li><p>新建仓库</p></li></ol><ul><li>注意：仓库地址必须和用户地址相同，因为公网访问的时候需要</li></ul><ol start="4"><li><p>安装部署插件 hexo-deployer-git</p><ul><li>npm install –save hexo-deployer-git</li></ul></li><li><p>设置_config.yml</p><ul><li><p>deploy</p><ul><li>type:git</li><li>repo:仓库地址</li><li>branch: master</li></ul></li></ul></li><li><p>部署到远端</p><ul><li>执行 hexo deploy 或 hexo d</li></ul></li></ol><h2 id="三、新建博客"><a href="#三、新建博客" class="headerlink" title="三、新建博客"></a>三、新建博客</h2><ol><li><p>执行 hexo new “博客名” 或者 hexo n “博客名”</p><ul><li>在 source/_posts 目录下即可看到新博客的 md 文件</li></ul></li><li><p>hexo clean（清理） → hexo g（生成）→ hexo s（启动）</p></li></ol><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><ol><li><p>下载主题</p><ul><li><p>git clone “主题 git 地址” theme/yilia</p></li><li><p>修改_config.yml 文件中的 theme：yilia</p></li><li><p>重新清理 → 生成 → 启动 → 部署到远端</p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/28/hello-world/"/>
      <url>2021/01/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
